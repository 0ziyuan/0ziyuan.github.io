<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Shell编程</title>
      <link href="/2021/05/30/Shell%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/05/30/Shell%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是-shell-脚本"><a href="#什么是-shell-脚本" class="headerlink" title="什么是 shell 脚本"></a>什么是 shell 脚本</h3><p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序，一般文件后缀为 <code>.sh</code>。</p><p>业界所说的 shell 通常都是指 shell 脚本，但 shell 和 shell script 是两个不同的概念。</p><h3 id="Shell-环境"><a href="#Shell-环境" class="headerlink" title="Shell 环境"></a>Shell 环境</h3><p>Shell 编程跟 java、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p><p>Shell 的解释器种类众多，常见的有：</p><ul><li><a href="https://www.gnu.org/software/bash/">sh</a> - 即 Bourne Shell。sh 是 Unix 标准默认的 shell。</li><li><a href="https://www.gnu.org/software/bash/">bash</a> - 即 Bourne Again Shell。bash 是 Linux 标准默认的 shell。</li><li><a href="https://fishshell.com/">fish</a> - 智能和用户友好的命令行 shell。</li><li><a href="http://xiki.org/">xiki</a> - 使 shell 控制台更友好，更强大。</li><li><a href="http://www.zsh.org/">zsh</a> - 功能强大的 shell 与脚本语言。</li></ul><h4 id="指定脚本解释器"><a href="#指定脚本解释器" class="headerlink" title="指定脚本解释器"></a>指定脚本解释器</h4><p>在 shell 脚本，<code>#!</code> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。<code>#!</code> 被称作<a href="https://zh.wikipedia.org/wiki/Shebang">shebang（也称为 Hashbang ）</a>。</p><p>所以，你应该会在 shell 中，见到诸如以下的注释：</p><ul><li>指定 sh 解释器</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br></pre></td></tr></table></figure><ul><li>指定 bash 解释器</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>上面的指定解释器的方式是比较常见的，但有时候，你可能也会看到下面的方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br></pre></td></tr></table></figure><p>这样做的好处是，系统会自动在 <code>PATH</code> 环境变量中查找你指定的程序（本例中的<code>bash</code>）。相比第一种写法，你应该尽量用这种写法，因为程序的路径是不确定的。这样写还有一个好处，操作系统的<code>PATH</code>变量有可能被配置为指向程序的另一个版本。比如，安装完新版本的<code>bash</code>，我们可能将其路径添加到<code>PATH</code>中，来“隐藏”老版本。如果直接用<code>#!/bin/bash</code>，那么系统会选择老版本的<code>bash</code>来执行脚本，如果用<code>#!/usr/bin/env bash</code>，则会使用新版本。</p></blockquote><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>shell 有交互和非交互两种模式。</p><h4 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h4><blockquote><p>简单来说，你可以将 shell 的交互模式理解为执行命令行。</p></blockquote><p>看到形如下面的东西，说明 shell 处于交互模式下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user@host:~$</span><br></pre></td></tr></table></figure><p>接着，便可以输入一系列 Linux 命令，比如 <code>ls</code>，<code>grep</code>，<code>cd</code>，<code>mkdir</code>，<code>rm</code> 等等。</p><h4 id="非交互模式"><a href="#非交互模式" class="headerlink" title="非交互模式"></a>非交互模式</h4><blockquote><p>简单来说，你可以将 shell 的非交互模式理解为执行 shell 脚本。</p></blockquote><p>在非交互模式下，shell 从文件或者管道中读取命令并执行。</p><p>当 shell 解释器执行完文件中的最后一个命令，shell 进程终止，并回到父进程。</p><p>可以使用下面的命令让 shell 以非交互模式运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh /path/to/script.sh</span><br><span class="line">bash /path/to/script.sh</span><br><span class="line"><span class="built_in">source</span> /path/to/script.sh</span><br><span class="line">./path/to/script.sh</span><br></pre></td></tr></table></figure><p>上面的例子中，<code>script.sh</code>是一个包含 shell 解释器可以识别并执行的命令的普通文本文件，<code>sh</code>和<code>bash</code>是 shell 解释器程序。你可以使用任何喜欢的编辑器创建<code>script.sh</code>（vim，nano，Sublime Text, Atom 等等）。</p><p>其中，<code>source /path/to/script.sh</code> 和 <code>./path/to/script.sh</code> 是等价的。</p><p>除此之外，你还可以通过<code>chmod</code>命令给文件添加可执行的权限，来直接执行脚本文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x /path/to/script.sh <span class="comment">#使脚本具有执行权限</span></span><br><span class="line">/path/to/test.sh</span><br></pre></td></tr></table></figure><p>这种方式要求脚本文件的第一行必须指明运行该脚本的程序，比如：</p><p><strong>⌨️ 『示例源码』</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, world!&quot;</span></span><br></pre></td></tr></table></figure><p>上面的例子中，我们使用了一个很有用的命令<code>echo</code>来输出字符串到屏幕上。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p>前面虽然两次提到了<code>#!</code> ，但是本着重要的事情说三遍的精神，这里再强调一遍：</p><p>在 shell 脚本，<code>#!</code> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 解释器。<code>#!</code> 被称作<a href="https://zh.wikipedia.org/wiki/Shebang">shebang（也称为 Hashbang ）</a>。</p><p><code>#!</code> 决定了脚本可以像一个独立的可执行文件一样执行，而不用在终端之前输入<code>sh</code>, <code>bash</code>, <code>python</code>, <code>php</code>等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下两种方式都可以指定 shell 解释器为 bash，第二种方式更好</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">#!/usr/bin/env bash</span></span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释可以说明你的代码是什么作用，以及为什么这样写。</p><p>shell 语法中，注释是特殊的语句，会被 shell 解释器忽略。</p><ul><li>单行注释 - 以 <code>#</code> 开头，到行尾结束。</li><li>多行注释 - 以 <code>:&lt;&lt;EOF</code> 开头，到 <code>EOF</code> 结束。</li></ul><p><strong>⌨️ 『示例源码』</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#--------------------------------------------</span></span><br><span class="line"><span class="comment"># shell 注释示例</span></span><br><span class="line"><span class="comment"># author：zp</span></span><br><span class="line"><span class="comment">#--------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># echo &#x27;这是单行注释&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########## 这是分割线 ##########</span></span><br><span class="line"></span><br><span class="line">:&lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">echo &#x27;这是多行注释&#x27;</span></span><br><span class="line"><span class="string">echo &#x27;这是多行注释&#x27;</span></span><br><span class="line"><span class="string">echo &#x27;这是多行注释&#x27;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>echo 用于字符串的输出。</p><p>输出普通字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello, world&quot;</span></span><br><span class="line"><span class="comment"># Output: hello, world</span></span><br></pre></td></tr></table></figure><p>输出含变量的字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello, \&quot;zp\&quot;&quot;</span></span><br><span class="line"><span class="comment"># Output: hello, &quot;zp&quot;</span></span><br></pre></td></tr></table></figure><p>输出含变量的字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=zp</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello, \&quot;<span class="variable">$&#123;name&#125;</span>\&quot;&quot;</span></span><br><span class="line"><span class="comment"># Output: hello, &quot;zp&quot;</span></span><br></pre></td></tr></table></figure><p>输出含换行符的字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出含换行符的字符串</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;YES\nNO&quot;</span></span><br><span class="line"><span class="comment">#  Output: YES\nNO</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;YES\nNO&quot;</span> <span class="comment"># -e 开启转义</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  YES</span></span><br><span class="line"><span class="comment">#  NO</span></span><br></pre></td></tr></table></figure><p>输出含不换行符的字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;YES&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;NO&quot;</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  YES</span></span><br><span class="line"><span class="comment">#  NO</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;YES\c&quot;</span> <span class="comment"># -e 开启转义 \c 不换行</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;NO&quot;</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  YESNO</span></span><br></pre></td></tr></table></figure><p>输出重定向至文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;test&quot;</span> &gt; test.txt</span><br></pre></td></tr></table></figure><p>输出执行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> `<span class="built_in">pwd</span>`</span><br><span class="line"><span class="comment">#  Output:(当前目录路径)</span></span><br></pre></td></tr></table></figure><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p>printf 用于格式化输出字符串。</p><p>默认，printf 不会像 echo 一样自动添加换行符，如果需要换行可以手动添加 <code>\n</code>。</p><p><strong>⌨️ 『示例源码』</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单引号</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&#x27;%d %s\n&#x27;</span> 1 <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="comment">#  Output:1 abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 双引号</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%d %s\n&quot;</span> 1 <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="comment">#  Output:1 abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无引号</span></span><br><span class="line"><span class="built_in">printf</span> %s abcdef</span><br><span class="line"><span class="comment">#  Output: abcdef(并不会换行)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式只指定了一个参数，但多出的参数仍然会按照该格式输出</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%s\n&quot;</span> abc def</span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  abc</span></span><br><span class="line"><span class="comment">#  def</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%s %s %s\n&quot;</span> a b c d e f g h i j</span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  a b c</span></span><br><span class="line"><span class="comment">#  d e f</span></span><br><span class="line"><span class="comment">#  g h i</span></span><br><span class="line"><span class="comment">#  j</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有参数，那么 %s 用 NULL 代替，%d 用 0 代替</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%s and %d \n&quot;</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#   and 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化输出</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-4s\n&quot;</span> 姓名 性别 体重kg</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-4.2f\n&quot;</span> 郭靖 男 66.1234</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-4.2f\n&quot;</span> 杨过 男 48.6543</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%-10s %-8s %-4.2f\n&quot;</span> 郭芙 女 47.9876</span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  姓名     性别   体重kg</span></span><br><span class="line"><span class="comment">#  郭靖     男      66.12</span></span><br><span class="line"><span class="comment">#  杨过     男      48.65</span></span><br><span class="line"><span class="comment">#  郭芙     女      47.99</span></span><br></pre></td></tr></table></figure><h4 id="printf-的转义符"><a href="#printf-的转义符" class="headerlink" title="printf 的转义符"></a>printf 的转义符</h4><table><thead><tr><th>序列</th><th>说明</th></tr></thead><tbody><tr><td><code>\a</code></td><td>警告字符，通常为 ASCII 的 BEL 字符</td></tr><tr><td><code>\b</code></td><td>后退</td></tr><tr><td><code>\c</code></td><td>抑制（不显示）输出结果中任何结尾的换行字符（只在%b 格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td></tr><tr><td><code>\f</code></td><td>换页（formfeed）</td></tr><tr><td><code>\n</code></td><td>换行</td></tr><tr><td><code>\r</code></td><td>回车（Carriage return）</td></tr><tr><td><code>\t</code></td><td>水平制表符</td></tr><tr><td><code>\v</code></td><td>垂直制表符</td></tr><tr><td><code>\\</code></td><td>一个字面上的反斜杠字符</td></tr><tr><td><code>\ddd</code></td><td>表示 1 到 3 位数八进制值的字符。仅在格式字符串中有效</td></tr><tr><td><code>\0ddd</code></td><td>表示 1 到 3 位的八进制值字符</td></tr></tbody></table><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>跟许多程序设计语言一样，你可以在 bash 中创建变量。</p><p>Bash 中没有数据类型，bash 中的变量可以保存一个数字、一个字符、一个字符串等等。同时无需提前声明变量，给变量赋值会直接创建变量。</p><h3 id="变量命名原则"><a href="#变量命名原则" class="headerlink" title="变量命名原则"></a>变量命名原则</h3><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用 bash 里的关键字（可用 help 命令查看保留关键字）。</li></ul><h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><p>访问变量的语法形式为：<code>$&#123;var&#125;</code> 和 <code>$var</code> 。</p><p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，所以推荐加花括号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">word=<span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;word&#125;</span></span><br><span class="line"><span class="comment"># Output: hello</span></span><br></pre></td></tr></table></figure><h3 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h3><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rword=<span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;rword&#125;</span></span><br><span class="line"><span class="built_in">readonly</span> rword</span><br><span class="line"><span class="comment"># rword=&quot;bye&quot;  # 如果放开注释，执行时会报错</span></span><br></pre></td></tr></table></figure><h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>使用 unset 命令可以删除变量。变量被删除后不能再次使用。unset 命令不能删除只读变量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dword=<span class="string">&quot;hello&quot;</span>  <span class="comment"># 声明变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;dword&#125;</span>  <span class="comment"># 输出变量值</span></span><br><span class="line"><span class="comment"># Output: hello</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">unset</span> dword    <span class="comment"># 删除变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;dword&#125;</span></span><br><span class="line"><span class="comment"># Output: （空）</span></span><br></pre></td></tr></table></figure><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ul><li><strong>局部变量</strong> - 局部变量是仅在某个脚本内部有效的变量。它们不能被其他的程序和脚本访问。</li><li><strong>环境变量</strong> - 环境变量是对当前 shell 会话内所有的程序或脚本都可见的变量。创建它们跟创建局部变量类似，但使用的是 <code>export</code> 关键字，shell 脚本也可以定义环境变量。</li></ul><p>常见的环境变量：</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td><code>$HOME</code></td><td>当前用户的用户目录</td></tr><tr><td><code>$PATH</code></td><td>用分号分隔的目录列表，shell 会到这些目录中查找命令</td></tr><tr><td><code>$PWD</code></td><td>当前工作目录</td></tr><tr><td><code>$RANDOM</code></td><td>0 到 32767 之间的整数</td></tr><tr><td><code>$UID</code></td><td>数值类型，当前用户的用户 ID</td></tr><tr><td><code>$PS1</code></td><td>主要系统输入提示符</td></tr><tr><td><code>$PS2</code></td><td>次要系统输入提示符</td></tr></tbody></table><p><a href="http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_02.html###sect_03_02_04">这里</a> 有一张更全面的 Bash 环境变量列表。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="单引号和双引号"><a href="#单引号和双引号" class="headerlink" title="单引号和双引号"></a>单引号和双引号</h3><p>shell 字符串可以用单引号 <code>&#39;&#39;</code>，也可以用双引号 <code>“”</code>，也可以不用引号。</p><ul><li>单引号的特点<ul><li>单引号里不识别变量</li><li>单引号里不能出现单独的单引号（使用转义符也不行），但可成对出现，作为字符串拼接使用。</li></ul></li><li>双引号的特点<ul><li>双引号里识别变量</li><li>双引号里可以出现转义字符</li></ul></li></ul><p>综上，推荐使用双引号。</p><h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用单引号拼接</span></span><br><span class="line">name1=<span class="string">&#x27;white&#x27;</span></span><br><span class="line">str1=<span class="string">&#x27;hello, &#x27;</span><span class="variable">$&#123;name1&#125;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">str2=<span class="string">&#x27;hello, $&#123;name1&#125;&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str1&#125;</span>_<span class="variable">$&#123;str2&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello, white_hello, $&#123;name1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用双引号拼接</span></span><br><span class="line">name2=<span class="string">&quot;black&quot;</span></span><br><span class="line">str3=<span class="string">&quot;hello, &quot;</span><span class="variable">$&#123;name2&#125;</span><span class="string">&quot;&quot;</span></span><br><span class="line">str4=<span class="string">&quot;hello, <span class="variable">$&#123;name2&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str3&#125;</span>_<span class="variable">$&#123;str4&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># hello, black_hello, black</span></span><br></pre></td></tr></table></figure><h3 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">text=<span class="string">&quot;12345&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#text&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure><h3 id="截取子字符串"><a href="#截取子字符串" class="headerlink" title="截取子字符串"></a>截取子字符串</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">text=<span class="string">&quot;12345&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;text:2:2&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 34</span></span><br></pre></td></tr></table></figure><p>从第 3 个字符开始，截取 2 个字符</p><h3 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">text=<span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="built_in">echo</span> `<span class="built_in">expr</span> index <span class="string">&quot;<span class="variable">$&#123;text&#125;</span>&quot;</span> ll`</span><br><span class="line"></span><br><span class="line"><span class="comment"># Execute: ./str-demo5.sh</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>查找 <code>ll</code> 子字符在 <code>hello</code> 字符串中的起始位置。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>bash 只支持一维数组。</p><p>数组下标从 0 开始，下标可以是整数或算术表达式，其值应大于或等于 0。</p><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数组的不同方式</span></span><br><span class="line">nums=([2]=2 [0]=0 [1]=1)</span><br><span class="line">colors=(red yellow <span class="string">&quot;dark blue&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><ul><li><strong>访问数组的单个元素：</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;nums[1]&#125;</span></span><br><span class="line"><span class="comment"># Output: 1</span></span><br></pre></td></tr></table></figure><ul><li><strong>访问数组的所有元素：</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[*]&#125;</span></span><br><span class="line"><span class="comment"># Output: red yellow dark blue</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[@]&#125;</span></span><br><span class="line"><span class="comment"># Output: red yellow dark blue</span></span><br></pre></td></tr></table></figure><p>上面两行有很重要（也很微妙）的区别：</p><p>为了将数组中每个元素单独一行输出，我们用 <code>printf</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&quot;+ %s\n&quot;</span> <span class="variable">$&#123;colors[*]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># + red</span></span><br><span class="line"><span class="comment"># + yellow</span></span><br><span class="line"><span class="comment"># + dark</span></span><br><span class="line"><span class="comment"># + blue</span></span><br></pre></td></tr></table></figure><p>为什么<code>dark</code>和<code>blue</code>各占了一行？尝试用引号包起来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&quot;+ %s\n&quot;</span> <span class="string">&quot;<span class="variable">$&#123;colors[*]&#125;</span>&quot;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># + red yellow dark blue</span></span><br></pre></td></tr></table></figure><p>现在所有的元素都在一行输出 —— 这不是我们想要的！让我们试试<code>$&#123;colors[@]&#125;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&quot;+ %s\n&quot;</span> <span class="string">&quot;<span class="variable">$&#123;colors[@]&#125;</span>&quot;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># + red</span></span><br><span class="line"><span class="comment"># + yellow</span></span><br><span class="line"><span class="comment"># + dark blue</span></span><br></pre></td></tr></table></figure><p>在引号内，<code>$&#123;colors[@]&#125;</code>将数组中的每个元素扩展为一个单独的参数；数组元素中的空格得以保留。</p><ul><li><strong>访问数组的部分元素：</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;nums[@]:0:2&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 0 1</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>$&#123;array[@]&#125;</code> 扩展为整个数组，<code>:0:2</code>取出了数组中从 0 开始，长度为 2 的元素。</p><h3 id="访问数组长度"><a href="#访问数组长度" class="headerlink" title="访问数组长度"></a>访问数组长度</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#nums[*]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure><h3 id="向数组中添加元素"><a href="#向数组中添加元素" class="headerlink" title="向数组中添加元素"></a>向数组中添加元素</h3><p>向数组中添加元素也非常简单：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">colors=(white <span class="string">&quot;<span class="variable">$&#123;colors[@]&#125;</span>&quot;</span> green black)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;colors[@]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># white red yellow dark blue green black</span></span><br></pre></td></tr></table></figure><p>上面的例子中，<code>$&#123;colors[@]&#125;</code> 扩展为整个数组，并被置换到复合赋值语句中，接着，对数组<code>colors</code>的赋值覆盖了它原来的值。</p><h3 id="从数组中删除元素"><a href="#从数组中删除元素" class="headerlink" title="从数组中删除元素"></a>从数组中删除元素</h3><p>用<code>unset</code>命令来从数组中删除一个元素：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> nums[0]</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;nums[@]&#125;</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 1 2</span></span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>下表列出了常用的算术运算符，假定变量 x 为 10，变量 y 为 20：</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>+</td><td>加法</td><td><code>expr $x + $y</code> 结果为 30。</td></tr><tr><td>-</td><td>减法</td><td><code>expr $x - $y</code> 结果为 -10。</td></tr><tr><td>*</td><td>乘法</td><td><code>expr $x * $y</code> 结果为 200。</td></tr><tr><td>&#x2F;</td><td>除法</td><td><code>expr $y / $x</code> 结果为 2。</td></tr><tr><td>%</td><td>取余</td><td><code>expr $y % $x</code> 结果为 0。</td></tr><tr><td>&#x3D;</td><td>赋值</td><td><code>x=$y</code> 将把变量 y 的值赋给 x。</td></tr><tr><td>&#x3D;&#x3D;</td><td>相等。用于比较两个数字，相同则返回 true。</td><td><code>[ $x == $y ]</code> 返回 false。</td></tr><tr><td>!&#x3D;</td><td>不相等。用于比较两个数字，不相同则返回 true。</td><td><code>[ $x != $y ]</code> 返回 true。</td></tr></tbody></table><p><strong>注意：</strong>条件表达式要放在方括号之间，并且要有空格，例如: <code>[$x==$y]</code> 是错误的，必须写成 <code>[ $x == $y ]</code>。</p><p><strong>⌨️ 『示例源码』</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">val=`<span class="built_in">expr</span> <span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span> = <span class="variable">$val</span>&quot;</span></span><br><span class="line"></span><br><span class="line">val=`<span class="built_in">expr</span> <span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span> = <span class="variable">$val</span>&quot;</span></span><br><span class="line"></span><br><span class="line">val=`<span class="built_in">expr</span> <span class="variable">$&#123;x&#125;</span> \* <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> * <span class="variable">$&#123;y&#125;</span> = <span class="variable">$val</span>&quot;</span></span><br><span class="line"></span><br><span class="line">val=`<span class="built_in">expr</span> <span class="variable">$&#123;y&#125;</span> / <span class="variable">$&#123;x&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;y&#125;</span> / <span class="variable">$&#123;x&#125;</span> = <span class="variable">$val</span>&quot;</span></span><br><span class="line"></span><br><span class="line">val=`<span class="built_in">expr</span> <span class="variable">$&#123;y&#125;</span> % <span class="variable">$&#123;x&#125;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;y&#125;</span> % <span class="variable">$&#123;x&#125;</span> = <span class="variable">$val</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> == <span class="variable">$&#123;y&#125;</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo.sh</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=10, y=20</span></span><br><span class="line"><span class="comment">#  10 + 20 = 30</span></span><br><span class="line"><span class="comment">#  10 - 20 = -10</span></span><br><span class="line"><span class="comment">#  10 * 20 = 200</span></span><br><span class="line"><span class="comment">#  20 / 10 = 2</span></span><br><span class="line"><span class="comment">#  20 % 10 = 0</span></span><br><span class="line"><span class="comment">#  10 != 20</span></span><br></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p><p>下表列出了常用的关系运算符，假定变量 x 为 10，变量 y 为 20：</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>-eq</code></td><td>检测两个数是否相等，相等返回 true。</td><td><code>[ $a -eq $b ]</code>返回 false。</td></tr><tr><td><code>-ne</code></td><td>检测两个数是否相等，不相等返回 true。</td><td><code>[ $a -ne $b ]</code> 返回 true。</td></tr><tr><td><code>-gt</code></td><td>检测左边的数是否大于右边的，如果是，则返回 true。</td><td><code>[ $a -gt $b ]</code> 返回 false。</td></tr><tr><td><code>-lt</code></td><td>检测左边的数是否小于右边的，如果是，则返回 true。</td><td><code>[ $a -lt $b ]</code> 返回 true。</td></tr><tr><td><code>-ge</code></td><td>检测左边的数是否大于等于右边的，如果是，则返回 true。</td><td><code>[ $a -ge $b ]</code> 返回 false。</td></tr><tr><td><code>-le</code></td><td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td><td><code>[ $a -le $b ]</code>返回 true。</td></tr></tbody></table><p><strong>⌨️ 『示例源码』</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -eq <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> -eq <span class="variable">$&#123;y&#125;</span> : x 等于 y&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> -eq <span class="variable">$&#123;y&#125;</span>: x 不等于 y&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -ne <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> -ne <span class="variable">$&#123;y&#125;</span>: x 不等于 y&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> -ne <span class="variable">$&#123;y&#125;</span>: x 等于 y&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -gt <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> -gt <span class="variable">$&#123;y&#125;</span>: x 大于 y&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> -gt <span class="variable">$&#123;y&#125;</span>: x 不大于 y&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> -lt <span class="variable">$&#123;y&#125;</span>: x 小于 y&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> -lt <span class="variable">$&#123;y&#125;</span>: x 不小于 y&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -ge <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> -ge <span class="variable">$&#123;y&#125;</span>: x 大于或等于 y&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> -ge <span class="variable">$&#123;y&#125;</span>: x 小于 y&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -le <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> -le <span class="variable">$&#123;y&#125;</span>: x 小于或等于 y&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> -le <span class="variable">$&#123;y&#125;</span>: x 大于 y&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo2.sh</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=10, y=20</span></span><br><span class="line"><span class="comment">#  10 -eq 20: x 不等于 y</span></span><br><span class="line"><span class="comment">#  10 -ne 20: x 不等于 y</span></span><br><span class="line"><span class="comment">#  10 -gt 20: x 不大于 y</span></span><br><span class="line"><span class="comment">#  10 -lt 20: x 小于 y</span></span><br><span class="line"><span class="comment">#  10 -ge 20: x 小于 y</span></span><br><span class="line"><span class="comment">#  10 -le 20: x 小于或等于 y</span></span><br></pre></td></tr></table></figure><h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><p>下表列出了常用的布尔运算符，假定变量 x 为 10，变量 y 为 20：</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>!</code></td><td>非运算，表达式为 true 则返回 false，否则返回 true。</td><td><code>[ ! false ]</code> 返回 true。</td></tr><tr><td><code>-o</code></td><td>或运算，有一个表达式为 true 则返回 true。</td><td><code>[ $a -lt 20 -o $b -gt 100 ]</code> 返回 true。</td></tr><tr><td><code>-a</code></td><td>与运算，两个表达式都为 true 才返回 true。</td><td><code>[ $a -lt 20 -a $b -gt 100 ]</code> 返回 false。</td></tr></tbody></table><p><strong>⌨️ 『示例源码』</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> : x 不等于 y&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span>: x 等于 y&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 100 &amp;&amp; <span class="variable">$&#123;y&#125;</span> -gt 15 ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> 小于 100 且 <span class="variable">$&#123;y&#125;</span> 大于 15 : 返回 true&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> 小于 100 且 <span class="variable">$&#123;y&#125;</span> 大于 15 : 返回 false&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 100 || <span class="variable">$&#123;y&#125;</span> -gt 100 ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> 小于 100 或 <span class="variable">$&#123;y&#125;</span> 大于 100 : 返回 true&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> 小于 100 或 <span class="variable">$&#123;y&#125;</span> 大于 100 : 返回 false&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 5 || <span class="variable">$&#123;y&#125;</span> -gt 100 ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> 小于 5 或 <span class="variable">$&#123;y&#125;</span> 大于 100 : 返回 true&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> 小于 5 或 <span class="variable">$&#123;y&#125;</span> 大于 100 : 返回 false&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo3.sh</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=10, y=20</span></span><br><span class="line"><span class="comment">#  10 != 20 : x 不等于 y</span></span><br><span class="line"><span class="comment">#  10 小于 100 且 20 大于 15 : 返回 true</span></span><br><span class="line"><span class="comment">#  10 小于 100 或 20 大于 100 : 返回 true</span></span><br><span class="line"><span class="comment">#  10 小于 5 或 20 大于 100 : 返回 false</span></span><br></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>以下介绍 Shell 的逻辑运算符，假定变量 x 为 10，变量 y 为 20:</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>逻辑的 AND</td><td><code>[[ $&#123;x&#125; -lt 100 &amp;&amp; $&#123;y&#125; -gt 100 ]]</code> 返回 false</td></tr><tr><td>&#96;</td><td></td><td>&#96;</td></tr></tbody></table><p><strong>⌨️ 『示例源码』</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 100 &amp;&amp; <span class="variable">$&#123;y&#125;</span> -gt 100 ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> -lt 100 &amp;&amp; <span class="variable">$&#123;y&#125;</span> -gt 100 返回 true&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> -lt 100 &amp;&amp; <span class="variable">$&#123;y&#125;</span> -gt 100 返回 false&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 100 || <span class="variable">$&#123;y&#125;</span> -gt 100 ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> -lt 100 || <span class="variable">$&#123;y&#125;</span> -gt 100 返回 true&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> -lt 100 || <span class="variable">$&#123;y&#125;</span> -gt 100 返回 false&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo4.sh</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=10, y=20</span></span><br><span class="line"><span class="comment">#  10 -lt 100 &amp;&amp; 20 -gt 100 返回 false</span></span><br><span class="line"><span class="comment">#  10 -lt 100 || 20 -gt 100 返回 true</span></span><br></pre></td></tr></table></figure><h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td><code>=</code></td><td>检测两个字符串是否相等，相等返回 true。</td><td><code>[ $a = $b ]</code> 返回 false。</td></tr><tr><td><code>!=</code></td><td>检测两个字符串是否相等，不相等返回 true。</td><td><code>[ $a != $b ]</code> 返回 true。</td></tr><tr><td><code>-z</code></td><td>检测字符串长度是否为 0，为 0 返回 true。</td><td><code>[ -z $a ]</code> 返回 false。</td></tr><tr><td><code>-n</code></td><td>检测字符串长度是否为 0，不为 0 返回 true。</td><td><code>[ -n $a ]</code> 返回 true。</td></tr><tr><td><code>str</code></td><td>检测字符串是否为空，不为空返回 true。</td><td><code>[ $a ]</code> 返回 true。</td></tr></tbody></table><p><strong>⌨️ 『示例源码』</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="string">&quot;abc&quot;</span></span><br><span class="line">y=<span class="string">&quot;xyz&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;x=<span class="variable">$&#123;x&#125;</span>, y=<span class="variable">$&#123;y&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span> : x 等于 y&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span>: x 不等于 y&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span> : x 不等于 y&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> != <span class="variable">$&#123;y&#125;</span>: x 等于 y&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -z <span class="variable">$&#123;x&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;-z <span class="variable">$&#123;x&#125;</span> : 字符串长度为 0&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;-z <span class="variable">$&#123;x&#125;</span> : 字符串长度不为 0&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="string">&quot;<span class="variable">$&#123;x&#125;</span>&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;-n <span class="variable">$&#123;x&#125;</span> : 字符串长度不为 0&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;-n <span class="variable">$&#123;x&#125;</span> : 字符串长度为 0&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> : 字符串不为空&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> : 字符串为空&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo5.sh</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  x=abc, y=xyz</span></span><br><span class="line"><span class="comment">#  abc = xyz: x 不等于 y</span></span><br><span class="line"><span class="comment">#  abc != xyz : x 不等于 y</span></span><br><span class="line"><span class="comment">#  -z abc : 字符串长度不为 0</span></span><br><span class="line"><span class="comment">#  -n abc : 字符串长度不为 0</span></span><br><span class="line"><span class="comment">#  abc : 字符串不为空</span></span><br></pre></td></tr></table></figure><h3 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h3><p>文件测试运算符用于检测 Unix 文件的各种属性。</p><p>属性检测描述如下：</p><table><thead><tr><th>操作符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>-b file</td><td>检测文件是否是块设备文件，如果是，则返回 true。</td><td><code>[ -b $file ]</code> 返回 false。</td></tr><tr><td>-c file</td><td>检测文件是否是字符设备文件，如果是，则返回 true。</td><td><code>[ -c $file ]</code> 返回 false。</td></tr><tr><td>-d file</td><td>检测文件是否是目录，如果是，则返回 true。</td><td><code>[ -d $file ]</code> 返回 false。</td></tr><tr><td>-f file</td><td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td><td><code>[ -f $file ]</code> 返回 true。</td></tr><tr><td>-g file</td><td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td><td><code>[ -g $file ]</code> 返回 false。</td></tr><tr><td>-k file</td><td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td><td><code>[ -k $file ]</code>返回 false。</td></tr><tr><td>-p file</td><td>检测文件是否是有名管道，如果是，则返回 true。</td><td><code>[ -p $file ]</code> 返回 false。</td></tr><tr><td>-u file</td><td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td><td><code>[ -u $file ]</code> 返回 false。</td></tr><tr><td>-r file</td><td>检测文件是否可读，如果是，则返回 true。</td><td><code>[ -r $file ]</code> 返回 true。</td></tr><tr><td>-w file</td><td>检测文件是否可写，如果是，则返回 true。</td><td><code>[ -w $file ]</code> 返回 true。</td></tr><tr><td>-x file</td><td>检测文件是否可执行，如果是，则返回 true。</td><td><code>[ -x $file ]</code> 返回 true。</td></tr><tr><td>-s file</td><td>检测文件是否为空（文件大小是否大于 0），不为空返回 true。</td><td><code>[ -s $file ]</code> 返回 true。</td></tr><tr><td>-e file</td><td>检测文件（包括目录）是否存在，如果是，则返回 true。</td><td><code>[ -e $file ]</code> 返回 true。</td></tr></tbody></table><p><strong>⌨️ 『示例源码』</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">file=<span class="string">&quot;/etc/hosts&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -r <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;file&#125;</span> 文件可读&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;file&#125;</span> 文件不可读&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -w <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;file&#125;</span> 文件可写&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;file&#125;</span> 文件不可写&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -x <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;file&#125;</span> 文件可执行&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;file&#125;</span> 文件不可执行&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -f <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;file&#125;</span> 文件为普通文件&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;file&#125;</span> 文件为特殊文件&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -d <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;file&#125;</span> 文件是个目录&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;file&#125;</span> 文件不是个目录&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -s <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;file&#125;</span> 文件不为空&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;file&#125;</span> 文件为空&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ -e <span class="variable">$&#123;file&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;file&#125;</span> 文件存在&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;file&#125;</span> 文件不存在&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  Execute: ./operator-demo6.sh</span></span><br><span class="line"><span class="comment">#  Output:(根据文件的实际情况，输出结果可能不同)</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件可读</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件可写</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件不可执行</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件为普通文件</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件不是个目录</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件不为空</span></span><br><span class="line"><span class="comment">#  /etc/hosts 文件存在</span></span><br></pre></td></tr></table></figure><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>跟其它程序设计语言一样，Bash 中的条件语句让我们可以决定一个操作是否被执行。结果取决于一个包在<code>[[ ]]</code>里的表达式。</p><p>由<code>[[ ]]</code>（<code>sh</code>中是<code>[ ]</code>）包起来的表达式被称作 <strong>检测命令</strong> 或 <strong>基元</strong>。这些表达式帮助我们检测一个条件的结果。这里可以找到有关<a href="http://serverfault.com/a/52050">bash 中单双中括号区别</a>的答案。</p><p>共有两个不同的条件表达式：<code>if</code>和<code>case</code>。</p><h4 id="if"><a href="#if" class="headerlink" title="if"></a><code>if</code></h4><p>（1）<code>if</code> 语句</p><p><code>if</code>在使用上跟其它语言相同。如果中括号里的表达式为真，那么<code>then</code>和<code>fi</code>之间的代码会被执行。<code>fi</code>标志着条件代码块的结束。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写成一行</span></span><br><span class="line"><span class="keyword">if</span> [[ 1 -eq 1 ]]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">&quot;1 -eq 1 result is: true&quot;</span>; <span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output: 1 -eq 1 result is: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写成多行</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;abc&quot;</span> -eq <span class="string">&quot;abc&quot;</span> ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;&quot;</span>abc<span class="string">&quot; -eq &quot;</span>abc<span class="string">&quot; result is: true&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output: abc -eq abc result is: true</span></span><br></pre></td></tr></table></figure><p>（2）<code>if else</code> 语句</p><p>同样，我们可以使用<code>if..else</code>语句，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ 2 -ne 1 ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;false&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output: true</span></span><br></pre></td></tr></table></figure><p>（3）<code>if elif else</code> 语句</p><p>有些时候，<code>if..else</code>不能满足我们的要求。别忘了<code>if..elif..else</code>，使用起来也很方便。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x=10</span><br><span class="line">y=20</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;x&#125;</span> &gt; <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> &gt; <span class="variable">$&#123;y&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [[ <span class="variable">$&#123;x&#125;</span> &lt; <span class="variable">$&#123;y&#125;</span> ]]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> &lt; <span class="variable">$&#123;y&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> = <span class="variable">$&#123;y&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Output: 10 &lt; 20</span></span><br></pre></td></tr></table></figure><p><strong>⌨️ 『示例源码』</strong></p><h4 id="case"><a href="#case" class="headerlink" title="case"></a><code>case</code></h4><p>如果你需要面对很多情况，分别要采取不同的措施，那么使用<code>case</code>会比嵌套的<code>if</code>更有用。使用<code>case</code>来解决复杂的条件判断，看起来像下面这样：</p><p><strong>⌨️ 『示例源码』</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$&#123;oper&#125;</span> <span class="keyword">in</span></span><br><span class="line">  <span class="string">&quot;+&quot;</span>)</span><br><span class="line">    val=`<span class="built_in">expr</span> <span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;val&#125;</span>&quot;</span></span><br><span class="line">  ;;</span><br><span class="line">  <span class="string">&quot;-&quot;</span>)</span><br><span class="line">    val=`<span class="built_in">expr</span> <span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;val&#125;</span>&quot;</span></span><br><span class="line">  ;;</span><br><span class="line">  <span class="string">&quot;*&quot;</span>)</span><br><span class="line">    val=`<span class="built_in">expr</span> <span class="variable">$&#123;x&#125;</span> \* <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> * <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;val&#125;</span>&quot;</span></span><br><span class="line">  ;;</span><br><span class="line">  <span class="string">&quot;/&quot;</span>)</span><br><span class="line">    val=`<span class="built_in">expr</span> <span class="variable">$&#123;x&#125;</span> / <span class="variable">$&#123;y&#125;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;x&#125;</span> / <span class="variable">$&#123;y&#125;</span> = <span class="variable">$&#123;val&#125;</span>&quot;</span></span><br><span class="line">  ;;</span><br><span class="line">  *)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Unknown oper!&quot;</span></span><br><span class="line">  ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>每种情况都是匹配了某个模式的表达式。<code>|</code>用来分割多个模式，<code>)</code>用来结束一个模式序列。第一个匹配上的模式对应的命令将会被执行。<code>*</code>代表任何不匹配以上给定模式的模式。命令块儿之间要用<code>;;</code>分隔。</p><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>循环其实不足为奇。跟其它程序设计语言一样，bash 中的循环也是只要控制条件为真就一直迭代执行的代码块。</p><p>Bash 中有四种循环：<code>for</code>，<code>while</code>，<code>until</code>和<code>select</code>。</p><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a><code>for</code>循环</h4><p><code>for</code>与它在 C 语言中的姊妹非常像。看起来是这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> elem1 elem2 ... elemN</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment">### 语句</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>在每次循环的过程中，<code>arg</code>依次被赋值为从<code>elem1</code>到<code>elemN</code>。这些值还可以是通配符或者<a href="https://github.com/denysdovhan/bash-handbook/blob/master/translations/zh-CN/README.md#%E5%A4%A7%E6%8B%AC%E5%8F%B7%E6%89%A9%E5%B1%95">大括号扩展</a>。</p><p>当然，我们还可以把<code>for</code>循环写在一行，但这要求<code>do</code>之前要有一个分号，就像下面这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>还有，如果你觉得<code>for..in..do</code>对你来说有点奇怪，那么你也可以像 C 语言那样使用<code>for</code>，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>当我们想对一个目录下的所有文件做同样的操作时，<code>for</code>就很方便了。举个例子，如果我们想把所有的<code>.bash</code>文件移动到<code>script</code>文件夹中，并给它们可执行权限，我们的脚本可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DIR=/home/zp</span><br><span class="line"><span class="keyword">for</span> FILE <span class="keyword">in</span> <span class="variable">$&#123;DIR&#125;</span>/*.sh; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">mv</span> <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;DIR&#125;</span>/scripts&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 将 /home/zp 目录下所有 sh 文件拷贝到 /home/zp/scripts</span></span><br></pre></td></tr></table></figure><p><strong>⌨️ 『示例源码』</strong></p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a><code>while</code>循环</h4><p><code>while</code>循环检测一个条件，只要这个条件为 <em>真</em>，就执行一段命令。被检测的条件跟<code>if..then</code>中使用的<a href="https://github.com/denysdovhan/bash-handbook/blob/master/translations/zh-CN/README.md#%E5%9F%BA%E5%85%83%E5%92%8C%E7%BB%84%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F">基元</a>并无二异。因此一个<code>while</code>循环看起来会是这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [[ condition ]]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment">### 语句</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>跟<code>for</code>循环一样，如果我们把<code>do</code>和被检测的条件写到一行，那么必须要在<code>do</code>之前加一个分号。</p><p>比如下面这个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 0到9之间每个数的平方</span></span><br><span class="line">x=0</span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$&#123;x&#125;</span> -lt 10 ]]; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> $((x * x))</span><br><span class="line">  x=$((x + <span class="number">1</span>))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  0</span></span><br><span class="line"><span class="comment">#  1</span></span><br><span class="line"><span class="comment">#  4</span></span><br><span class="line"><span class="comment">#  9</span></span><br><span class="line"><span class="comment">#  16</span></span><br><span class="line"><span class="comment">#  25</span></span><br><span class="line"><span class="comment">#  36</span></span><br><span class="line"><span class="comment">#  49</span></span><br><span class="line"><span class="comment">#  64</span></span><br><span class="line"><span class="comment">#  81</span></span><br></pre></td></tr></table></figure><p><strong>⌨️ 『示例源码』</strong></p><h4 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a><code>until</code>循环</h4><p><code>until</code>循环跟<code>while</code>循环正好相反。它跟<code>while</code>一样也需要检测一个测试条件，但不同的是，只要该条件为 <em>假</em> 就一直执行循环：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x=0</span><br><span class="line"><span class="keyword">until</span> [[ <span class="variable">$&#123;x&#125;</span> -ge 5 ]]; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$&#123;x&#125;</span></span><br><span class="line">  x=`<span class="built_in">expr</span> <span class="variable">$&#123;x&#125;</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  0</span></span><br><span class="line"><span class="comment">#  1</span></span><br><span class="line"><span class="comment">#  2</span></span><br><span class="line"><span class="comment">#  3</span></span><br><span class="line"><span class="comment">#  4</span></span><br></pre></td></tr></table></figure><p><strong>⌨️ 『示例源码』</strong></p><h4 id="select循环"><a href="#select循环" class="headerlink" title="select循环"></a><code>select</code>循环</h4><p><code>select</code>循环帮助我们组织一个用户菜单。它的语法几乎跟<code>for</code>循环一致：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> answer <span class="keyword">in</span> elem1 elem2 ... elemN</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="comment">### 语句</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><code>select</code>会打印<code>elem1..elemN</code>以及它们的序列号到屏幕上，之后会提示用户输入。通常看到的是<code>$?</code>（<code>PS3</code>变量）。用户的选择结果会被保存到<code>answer</code>中。如果<code>answer</code>是一个在<code>1..N</code>之间的数字，那么<code>语句</code>会被执行，紧接着会进行下一次迭代 —— 如果不想这样的话我们可以使用<code>break</code>语句。</p><p>一个可能的实例可能会是这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">PS3=<span class="string">&quot;Choose the package manager: &quot;</span></span><br><span class="line"><span class="keyword">select</span> ITEM <span class="keyword">in</span> bower npm gem pip</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;Enter the package name: &quot;</span> &amp;&amp; <span class="built_in">read</span> PACKAGE</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$&#123;ITEM&#125;</span> <span class="keyword">in</span></span><br><span class="line">  bower) bower install <span class="variable">$&#123;PACKAGE&#125;</span> ;;</span><br><span class="line">  npm) npm install <span class="variable">$&#123;PACKAGE&#125;</span> ;;</span><br><span class="line">  gem) gem install <span class="variable">$&#123;PACKAGE&#125;</span> ;;</span><br><span class="line">  pip) pip install <span class="variable">$&#123;PACKAGE&#125;</span> ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="built_in">break</span> <span class="comment"># 避免无限循环</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>这个例子，先询问用户他想使用什么包管理器。接着，又询问了想安装什么包，最后执行安装操作。</p><p>运行这个脚本，会得到如下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./my_script</span><br><span class="line">1) bower</span><br><span class="line">2) npm</span><br><span class="line">3) gem</span><br><span class="line">4) pip</span><br><span class="line">Choose the package manager: 2</span><br><span class="line">Enter the package name: gitbook-cli</span><br></pre></td></tr></table></figure><p><strong>⌨️ 『示例源码』</strong></p><h4 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a><code>break</code> 和 <code>continue</code></h4><p>如果想提前结束一个循环或跳过某次循环执行，可以使用 shell 的<code>break</code>和<code>continue</code>语句来实现。它们可以在任何循环中使用。</p><blockquote><p><code>break</code>语句用来提前结束当前循环。</p><p><code>continue</code>语句用来跳过某次迭代。</p></blockquote><p><strong>⌨️ 『示例源码』</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找 10 以内第一个能整除 2 和 3 的正整数</span></span><br><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span> [[ <span class="variable">$&#123;i&#125;</span> -lt 10 ]]; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [[ $((i % <span class="number">3</span>)) -eq 0 ]] &amp;&amp; [[ $((i % <span class="number">2</span>)) -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$&#123;i&#125;</span></span><br><span class="line">    <span class="built_in">break</span>;</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  i=`<span class="built_in">expr</span> <span class="variable">$&#123;i&#125;</span> + 1`</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># Output: 6</span></span><br></pre></td></tr></table></figure><p><strong>⌨️ 『示例源码』</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印10以内的奇数</span></span><br><span class="line"><span class="keyword">for</span> (( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ )); <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [[ $((i % <span class="number">2</span>)) -eq 0 ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">continue</span>;</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$&#123;i&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  1</span></span><br><span class="line"><span class="comment">#  3</span></span><br><span class="line"><span class="comment">#  5</span></span><br><span class="line"><span class="comment">#  7</span></span><br><span class="line"><span class="comment">#  9</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>bash 函数定义语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname [()] &#123;</span><br><span class="line">    action;</span><br><span class="line">    [<span class="built_in">return</span> int;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>💡 说明：</p><ol><li>函数定义时，<code>function</code> 关键字可有可无。</li><li>函数返回值 - return 返回函数返回值，返回值类型只能为整数（0-255）。如果不加 return 语句，shell 默认将以最后一条命令的运行结果，作为函数返回值。</li><li>函数返回值在调用该函数后通过 <code>$?</code> 来获得。</li><li>所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至 shell 解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</li></ol></blockquote><p><strong>⌨️ 『示例源码』</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">calc</span></span>()&#123;</span><br><span class="line">  PS3=<span class="string">&quot;choose the oper: &quot;</span></span><br><span class="line">  <span class="keyword">select</span> oper <span class="keyword">in</span> + - \* / <span class="comment"># 生成操作符选择菜单</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> -n <span class="string">&quot;enter first num: &quot;</span> &amp;&amp; <span class="built_in">read</span> x <span class="comment"># 读取输入参数</span></span><br><span class="line">  <span class="built_in">echo</span> -n <span class="string">&quot;enter second num: &quot;</span> &amp;&amp; <span class="built_in">read</span> y <span class="comment"># 读取输入参数</span></span><br><span class="line">  <span class="built_in">exec</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$&#123;oper&#125;</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">&quot;+&quot;</span>)</span><br><span class="line">      <span class="built_in">return</span> $((<span class="variable">$&#123;x&#125;</span> + <span class="variable">$&#123;y&#125;</span>))</span><br><span class="line">    ;;</span><br><span class="line">    <span class="string">&quot;-&quot;</span>)</span><br><span class="line">      <span class="built_in">return</span> $((<span class="variable">$&#123;x&#125;</span> - <span class="variable">$&#123;y&#125;</span>))</span><br><span class="line">    ;;</span><br><span class="line">    <span class="string">&quot;*&quot;</span>)</span><br><span class="line">      <span class="built_in">return</span> $((<span class="variable">$&#123;x&#125;</span> * <span class="variable">$&#123;y&#125;</span>))</span><br><span class="line">    ;;</span><br><span class="line">    <span class="string">&quot;/&quot;</span>)</span><br><span class="line">      <span class="built_in">return</span> $((<span class="variable">$&#123;x&#125;</span> / <span class="variable">$&#123;y&#125;</span>))</span><br><span class="line">    ;;</span><br><span class="line">    *)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;oper&#125;</span> is not support!&quot;</span></span><br><span class="line">      <span class="built_in">return</span> 0</span><br><span class="line">    ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line">  <span class="built_in">break</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line">calc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;the result is: $?&quot;</span> <span class="comment"># $? 获取 calc 函数返回值</span></span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ./function-demo.sh</span><br><span class="line">1) +</span><br><span class="line">2) -</span><br><span class="line">3) *</span><br><span class="line">4) /</span><br><span class="line">choose the oper: 3</span><br><span class="line">enter first num: 10</span><br><span class="line">enter second num: 10</span><br><span class="line">the result is: 100</span><br></pre></td></tr></table></figure><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p><strong>位置参数</strong>是在调用一个函数并传给它参数时创建的变量。</p><p>位置参数变量表：</p><table><thead><tr><th>变量</th><th>描述</th></tr></thead><tbody><tr><td><code>$0</code></td><td>脚本名称</td></tr><tr><td><code>$1 … $9</code></td><td>第 1 个到第 9 个参数列表</td></tr><tr><td><code>$&#123;10&#125; … $&#123;N&#125;</code></td><td>第 10 个到 N 个参数列表</td></tr><tr><td><code>$*</code> or <code>$@</code></td><td>除了<code>$0</code>外的所有位置参数</td></tr><tr><td><code>$#</code></td><td>不包括<code>$0</code>在内的位置参数的个数</td></tr><tr><td><code>$FUNCNAME</code></td><td>函数名称（仅在函数内部有值）</td></tr></tbody></table><p><strong>⌨️ 『示例源码』</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">x=0</span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="variable">$1</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;第一个参数为：<span class="variable">$1</span>&quot;</span></span><br><span class="line">  x=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;第一个参数为空&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">y=0</span><br><span class="line"><span class="keyword">if</span> [[ -n <span class="variable">$2</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;第二个参数为：<span class="variable">$2</span>&quot;</span></span><br><span class="line">  y=<span class="variable">$2</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;第二个参数为空&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">paramsFunction</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;函数第一个入参：<span class="variable">$1</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;函数第二个入参：<span class="variable">$2</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">paramsFunction <span class="variable">$&#123;x&#125;</span> <span class="variable">$&#123;y&#125;</span></span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./function-demo2.sh</span><br><span class="line">第一个参数为空</span><br><span class="line">第二个参数为空</span><br><span class="line">函数第一个入参：0</span><br><span class="line">函数第二个入参：0</span><br><span class="line"></span><br><span class="line">$ ./function-demo2.sh 10 20</span><br><span class="line">第一个参数为：10</span><br><span class="line">第二个参数为：20</span><br><span class="line">函数第一个入参：10</span><br><span class="line">函数第二个入参：20</span><br></pre></td></tr></table></figure><p>执行 <code>./variable-demo4.sh hello world</code> ，然后在脚本中通过 <code>$1</code>、<code>$2</code> … 读取第 1 个参数、第 2 个参数。。。</p><h3 id="函数处理参数"><a href="#函数处理参数" class="headerlink" title="函数处理参数"></a>函数处理参数</h3><p>另外，还有几个特殊字符用来处理参数：</p><table><thead><tr><th>参数处理</th><th>说明</th></tr></thead><tbody><tr><td><code>$#</code></td><td>返回参数个数</td></tr><tr><td><code>$*</code></td><td>返回所有参数</td></tr><tr><td><code>$$</code></td><td>脚本运行的当前进程 ID 号</td></tr><tr><td><code>$!</code></td><td>后台运行的最后一个进程的 ID 号</td></tr><tr><td><code>$@</code></td><td>返回所有参数</td></tr><tr><td><code>$-</code></td><td>返回 Shell 使用的当前选项，与 set 命令功能相同。</td></tr><tr><td><code>$?</code></td><td>函数返回值</td></tr></tbody></table><p><strong>⌨️ 『示例源码』</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">runner</span></span>() &#123;</span><br><span class="line">  <span class="built_in">return</span> 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">name=zp</span><br><span class="line"><span class="function"><span class="title">paramsFunction</span></span>()&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;函数第一个入参：<span class="variable">$1</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;函数第二个入参：<span class="variable">$2</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;传递到脚本的参数个数：<span class="variable">$#</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;所有参数：&quot;</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="string">&quot;+ %s\n&quot;</span> <span class="string">&quot;$*&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;脚本运行的当前进程 ID 号：$$&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;后台运行的最后一个进程的 ID 号：$!&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;所有参数：&quot;</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="string">&quot;+ %s\n&quot;</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Shell 使用的当前选项：$-&quot;</span></span><br><span class="line">  runner</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;runner 函数的返回值：$?&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">paramsFunction 1 <span class="string">&quot;abc&quot;</span> <span class="string">&quot;hello, \&quot;zp\&quot;&quot;</span></span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  函数第一个入参：1</span></span><br><span class="line"><span class="comment">#  函数第二个入参：abc</span></span><br><span class="line"><span class="comment">#  传递到脚本的参数个数：3</span></span><br><span class="line"><span class="comment">#  所有参数：</span></span><br><span class="line"><span class="comment">#  + 1 abc hello, &quot;zp&quot;</span></span><br><span class="line"><span class="comment">#  脚本运行的当前进程 ID 号：26400</span></span><br><span class="line"><span class="comment">#  后台运行的最后一个进程的 ID 号：</span></span><br><span class="line"><span class="comment">#  所有参数：</span></span><br><span class="line"><span class="comment">#  + 1</span></span><br><span class="line"><span class="comment">#  + abc</span></span><br><span class="line"><span class="comment">#  + hello, &quot;zp&quot;</span></span><br><span class="line"><span class="comment">#  Shell 使用的当前选项：hB</span></span><br><span class="line"><span class="comment">#  runner 函数的返回值：0</span></span><br></pre></td></tr></table></figure><h2 id="Shell-扩展"><a href="#Shell-扩展" class="headerlink" title="Shell 扩展"></a>Shell 扩展</h2><p><em>扩展</em> 发生在一行命令被分成一个个的 <em>记号（tokens）</em> 之后。换言之，扩展是一种执行数学运算的机制，还可以用来保存命令的执行结果，等等。</p><p>感兴趣的话可以阅读<a href="https://www.gnu.org/software/bash/manual/bash.html###Shell-Expansions">关于 shell 扩展的更多细节</a>。</p><h4 id="大括号扩展"><a href="#大括号扩展" class="headerlink" title="大括号扩展"></a>大括号扩展</h4><p>大括号扩展让生成任意的字符串成为可能。它跟 <em>文件名扩展</em> 很类似，举个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> beg&#123;i,a,u&#125;n <span class="comment">### begin began begun</span></span><br></pre></td></tr></table></figure><p>大括号扩展还可以用来创建一个可被循环迭代的区间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> &#123;0..5&#125; <span class="comment">### 0 1 2 3 4 5</span></span><br><span class="line"><span class="built_in">echo</span> &#123;00..8..2&#125; <span class="comment">### 00 02 04 06 08</span></span><br></pre></td></tr></table></figure><h4 id="命令置换"><a href="#命令置换" class="headerlink" title="命令置换"></a>命令置换</h4><p>命令置换允许我们对一个命令求值，并将其值置换到另一个命令或者变量赋值表达式中。当一个命令被&#96;&#96;或<code>$()</code>包围时，命令置换将会执行。举个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">now=`<span class="built_in">date</span> +%T`</span><br><span class="line"><span class="comment">### or</span></span><br><span class="line">now=$(<span class="built_in">date</span> +%T)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$now</span> <span class="comment">### 19:08:26</span></span><br></pre></td></tr></table></figure><h4 id="算数扩展"><a href="#算数扩展" class="headerlink" title="算数扩展"></a>算数扩展</h4><p>在 bash 中，执行算数运算是非常方便的。算数表达式必须包在<code>$(( ))</code>中。算数扩展的格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result=$(( ((<span class="number">10</span> + <span class="number">5</span>*<span class="number">3</span>) - <span class="number">7</span>) / <span class="number">2</span> ))</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span> <span class="comment">### 9</span></span><br></pre></td></tr></table></figure><p>在算数表达式中，使用变量无需带上<code>$</code>前缀：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x=4</span><br><span class="line">y=7</span><br><span class="line"><span class="built_in">echo</span> $(( x + y ))     <span class="comment">### 11</span></span><br><span class="line"><span class="built_in">echo</span> $(( ++x + y++ )) <span class="comment">### 12</span></span><br><span class="line"><span class="built_in">echo</span> $(( x + y ))     <span class="comment">### 13</span></span><br></pre></td></tr></table></figure><h4 id="单引号和双引号-1"><a href="#单引号和双引号-1" class="headerlink" title="单引号和双引号"></a>单引号和双引号</h4><p>单引号和双引号之间有很重要的区别。在双引号中，变量引用或者命令置换是会被展开的。在单引号中是不会的。举个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Your home: <span class="variable">$HOME</span>&quot;</span> <span class="comment">### Your home: /Users/&lt;username&gt;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Your home: $HOME&#x27;</span> <span class="comment">### Your home: $HOME</span></span><br></pre></td></tr></table></figure><p>当局部变量和环境变量包含空格时，它们在引号中的扩展要格外注意。随便举个例子，假如我们用<code>echo</code>来输出用户的输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INPUT=<span class="string">&quot;A string  with   strange    whitespace.&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$INPUT</span>   <span class="comment">### A string with strange whitespace.</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$INPUT</span>&quot;</span> <span class="comment">### A string  with   strange    whitespace.</span></span><br></pre></td></tr></table></figure><p>调用第一个<code>echo</code>时给了它 5 个单独的参数 —— <code>$INPUT</code> 被分成了单独的词，<code>echo</code>在每个词之间打印了一个空格。第二种情况，调用<code>echo</code>时只给了它一个参数（整个$INPUT 的值，包括其中的空格）。</p><p>来看一个更严肃的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FILE=<span class="string">&quot;Favorite Things.txt&quot;</span></span><br><span class="line"><span class="built_in">cat</span> <span class="variable">$FILE</span>   <span class="comment">### 尝试输出两个文件: `Favorite` 和 `Things.txt`</span></span><br><span class="line"><span class="built_in">cat</span> <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span> <span class="comment">### 输出一个文件: `Favorite Things.txt`</span></span><br></pre></td></tr></table></figure><p>尽管这个问题可以通过把 FILE 重命名成<code>Favorite-Things.txt</code>来解决，但是，假如这个值来自某个环境变量，来自一个位置参数，或者来自其它命令（<code>find</code>, <code>cat</code>, 等等）呢。因此，如果输入 <em>可能</em> 包含空格，务必要用引号把表达式包起来。</p><h2 id="流和重定向"><a href="#流和重定向" class="headerlink" title="流和重定向"></a>流和重定向</h2><p>Bash 有很强大的工具来处理程序之间的协同工作。使用流，我们能将一个程序的输出发送到另一个程序或文件，因此，我们能方便地记录日志或做一些其它我们想做的事。</p><p>管道给了我们创建传送带的机会，控制程序的执行成为可能。</p><p>学习如何使用这些强大的、高级的工具是非常非常重要的。</p><h3 id="输入、输出流"><a href="#输入、输出流" class="headerlink" title="输入、输出流"></a>输入、输出流</h3><p>Bash 接收输入，并以字符序列或 <strong>字符流</strong> 的形式产生输出。这些流能被重定向到文件或另一个流中。</p><p>有三个文件描述符：</p><table><thead><tr><th>代码</th><th>描述符</th><th>描述</th></tr></thead><tbody><tr><td><code>0</code></td><td><code>stdin</code></td><td>标准输入</td></tr><tr><td><code>1</code></td><td><code>stdout</code></td><td>标准输出</td></tr><tr><td><code>2</code></td><td><code>stderr</code></td><td>标准错误输出</td></tr></tbody></table><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>重定向让我们可以控制一个命令的输入来自哪里，输出结果到什么地方。这些运算符在控制流的重定向时会被用到：</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><code>&gt;</code></td><td>重定向输出</td></tr><tr><td><code>&amp;&gt;</code></td><td>重定向输出和错误输出</td></tr><tr><td><code>&amp;&gt;&gt;</code></td><td>以附加的形式重定向输出和错误输出</td></tr><tr><td><code>&lt;</code></td><td>重定向输入</td></tr><tr><td><code>&lt;&lt;</code></td><td><a href="http://tldp.org/LDP/abs/html/here-docs.html">Here 文档</a> 语法</td></tr><tr><td><code>&lt;&lt;&lt;</code></td><td><a href="http://www.tldp.org/LDP/abs/html/x17837.html">Here 字符串</a></td></tr></tbody></table><p>以下是一些使用重定向的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### ls的结果将会被写到list.txt中</span></span><br><span class="line"><span class="built_in">ls</span> -l &gt; list.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">### 将输出附加到list.txt中</span></span><br><span class="line"><span class="built_in">ls</span> -a &gt;&gt; list.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">### 所有的错误信息会被写到errors.txt中</span></span><br><span class="line">grep da * 2&gt; errors.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">### 从errors.txt中读取输入</span></span><br><span class="line">less &lt; errors.txt</span><br></pre></td></tr></table></figure><h3 id="dev-null-文件"><a href="#dev-null-文件" class="headerlink" title="/dev/null 文件"></a><code>/dev/null</code> 文件</h3><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 &#x2F;dev&#x2F;null：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">command</span> &gt; /dev/null</span><br></pre></td></tr></table></figure><p>&#x2F;dev&#x2F;null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 &#x2F;dev&#x2F;null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。</p><p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">command</span> &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>shell 提供了用于 debug 脚本的工具。</p><p>如果想采用 debug 模式运行某脚本，可以在其 shebang 中使用一个特殊的选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash options</span></span><br></pre></td></tr></table></figure><p>options 是一些可以改变 shell 行为的选项。下表是一些可能对你有用的选项：</p><table><thead><tr><th>Short</th><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><code>-f</code></td><td>noglob</td><td>禁止文件名展开（globbing）</td></tr><tr><td><code>-i</code></td><td>interactive</td><td>让脚本以 <em>交互</em> 模式运行</td></tr><tr><td><code>-n</code></td><td>noexec</td><td>读取命令，但不执行（语法检查）</td></tr><tr><td><code>-t</code></td><td>—</td><td>执行完第一条命令后退出</td></tr><tr><td><code>-v</code></td><td>verbose</td><td>在执行每条命令前，向<code>stderr</code>输出该命令</td></tr><tr><td><code>-x</code></td><td>xtrace</td><td>在执行每条命令前，向<code>stderr</code>输出该命令以及该命令的扩展参数</td></tr></tbody></table><p>举个例子，如果我们在脚本中指定了<code>-x</code>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash -x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (( i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ )); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>这会向<code>stdout</code>打印出变量的值和一些其它有用的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ ./my_script</span><br><span class="line">+ (( i = <span class="number">0</span> ))</span><br><span class="line">+ (( i &lt; <span class="number">3</span> ))</span><br><span class="line">+ <span class="built_in">echo</span> 0</span><br><span class="line">0</span><br><span class="line">+ (( i++  ))</span><br><span class="line">+ (( i &lt; <span class="number">3</span> ))</span><br><span class="line">+ <span class="built_in">echo</span> 1</span><br><span class="line">1</span><br><span class="line">+ (( i++  ))</span><br><span class="line">+ (( i &lt; <span class="number">3</span> ))</span><br><span class="line">+ <span class="built_in">echo</span> 2</span><br><span class="line">2</span><br><span class="line">+ (( i++  ))</span><br><span class="line">+ (( i &lt; <span class="number">3</span> ))</span><br></pre></td></tr></table></figure><p>有时我们值需要 debug 脚本的一部分。这种情况下，使用<code>set</code>命令会很方便。这个命令可以启用或禁用选项。使用<code>-</code>启用选项，<code>+</code>禁用选项：</p><p><strong>⌨️ 『示例源码』</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启 debug</span></span><br><span class="line"><span class="built_in">set</span> -x</span><br><span class="line"><span class="keyword">for</span> (( i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ )); <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="variable">$&#123;i&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 关闭 debug</span></span><br><span class="line"><span class="built_in">set</span> +x</span><br><span class="line"><span class="comment">#  Output:</span></span><br><span class="line"><span class="comment">#  + (( i = 0 ))</span></span><br><span class="line"><span class="comment">#  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="comment">#  + printf 0</span></span><br><span class="line"><span class="comment">#  0+ (( i++  ))</span></span><br><span class="line"><span class="comment">#  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="comment">#  + printf 1</span></span><br><span class="line"><span class="comment">#  1+ (( i++  ))</span></span><br><span class="line"><span class="comment">#  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="comment">#  + printf 2</span></span><br><span class="line"><span class="comment">#  2+ (( i++  ))</span></span><br><span class="line"><span class="comment">#  + (( i &lt; 3 ))</span></span><br><span class="line"><span class="comment">#  + set +x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;; <span class="keyword">do</span> <span class="built_in">printf</span> <span class="variable">$&#123;i&#125;</span>; <span class="keyword">done</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="comment">#  Output: 12345</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>种子</title>
      <link href="/2021/05/22/%E7%A7%8D%E5%AD%90/"/>
      <url>/2021/05/22/%E7%A7%8D%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/post/%E7%A7%8D%E5%AD%90/%E7%A7%8D%E5%AD%90.jpg" alt="种子" title="种子"></p>]]></content>
      
      
      <categories>
          
          <category> 社会 </category>
          
          <category> 人物 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 社会 </tag>
            
            <tag> 人物 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GNU工具链</title>
      <link href="/2021/05/20/GNU%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
      <url>/2021/05/20/GNU%E5%B7%A5%E5%85%B7%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>Gnu toolchain是开发操作系统、应用程序的一套完整的程序和库，包括gcc、gdb、glibc：</p><p>•cpp</p><p>•m4</p><p>•gas</p><p>•gcc、g++</p><p>•ld</p><p>•glibc、libc++</p><p>•gdb</p><p>•makefile</p><p>•libtool</p><p>•binutils: ar、objdump、c++filt、nm、readelf等</p><p>•autoconf、automake</p><p>相当与工业制造中的母机</p><h2 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h2><p>是一族编译器，包括c、c++、go、java等</p><h4 id="前端-后端"><a href="#前端-后端" class="headerlink" title="前端+后端"></a>前端+后端</h4><p>•.c为后缀的文件，C语言源代码文件；</p><p>•.a为后缀的文件，是由目标文件构成的档案库文件；</p><p>•.C、.cc或.cxx 为后缀的文件，是C++源代码文件；</p><p>•.h为后缀的文件，是程序所包含的头文件；</p><p>•.i 为后缀的文件，是已经预处理过的C源代码文件；</p><p>•.ii为后缀的文件，是已经预处理过的C++源代码文件；</p><p>•.m为后缀的文件，是Objective-C源代码文件；</p><p>•.o为后缀的文件，是编译后的目标文件；</p><p>•.s为后缀的文件，是汇编语言源代码文件；</p><p>•.S为后缀的文件，是经过预编译的汇编语言源代码文件。</p><h4 id="C语言编译过程"><a href="#C语言编译过程" class="headerlink" title="C语言编译过程"></a>C语言编译过程</h4><p>•gcc -E hello.c -o hello.i</p><p>•gcc -S hello.i -o hello.s </p><p>•gcc -c hello.s -o hello.o</p><p>•gcc -o hello hello.o</p><p><img src="/img/post/GNU%E5%B7%A5%E5%85%B7%E9%93%BE/C%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B.png" alt="C语言编译过程" title="C语言编译过程"></p><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><p>•gdb program</p><table><thead><tr><th><strong>命令</strong></th><th><strong>缩写</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>list</td><td>l</td><td>打印当前位置源码</td></tr><tr><td>break</td><td>b</td><td>设置断点</td></tr><tr><td>run</td><td>r</td><td>运行程序</td></tr><tr><td>step</td><td>s</td><td>单步，进入函数</td></tr><tr><td>next</td><td>n</td><td>单步，不进入函数</td></tr><tr><td>print</td><td>p</td><td>打印变量</td></tr><tr><td>continue</td><td>c</td><td>继续运行</td></tr><tr><td>backtrace</td><td>bt</td><td>显示调用栈</td></tr><tr><td>info  threads</td><td></td><td>显示线程</td></tr><tr><td>thread  n</td><td></td><td>切换线程</td></tr><tr><td>set scheduler-locking on</td><td></td><td>关闭线程调度</td></tr></tbody></table><h2 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h2><p>Makefile用于工程组织和编译</p><p>与常见的命令式语言不同，它是一种依赖推导语言</p><p>Shell语言：变量定义+命令执行</p><p>Makefile：变量定义+依赖描述</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>count_words: count_words.o lexer.o -lfl<br>  gcc count_words.o lexer.o -lfl -o count_words </p><p>target: dependencies, …</p><p>actions</p><h4 id="显式规则与隐式规则"><a href="#显式规则与隐式规则" class="headerlink" title="显式规则与隐式规则"></a>显式规则与隐式规则</h4><p>%.o: %.c<br>  $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</p><h5 id="推导规则"><a href="#推导规则" class="headerlink" title="推导规则"></a>推导规则</h5><p>•检查目标和依赖文件的时间，如果依赖更新，则执行动作</p><p>•显式规则 &gt; 隐式规则</p><h5 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h5><p>•动态规划</p><p>•从target出发，枚举所有规则，直到依赖可达</p><h4 id="Makefile的主要问题"><a href="#Makefile的主要问题" class="headerlink" title="Makefile的主要问题"></a>Makefile的主要问题</h4><ol><li>推导结论没有显式导出，不便于理解</li><li>应该保存为中间结果，下次编译直接调用</li><li>中间结果保存为一棵树，同时编译</li></ol><h2 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h2><p>cross platform make跨平台自动化建置系统</p><h4 id="Cmake-vs-Makefile"><a href="#Cmake-vs-Makefile" class="headerlink" title="Cmake vs Makefile"></a>Cmake vs Makefile</h4><p>•Makefile的依赖推导不直观</p><p>•Cmake的语法设计采用命令式</p><p>•跨平台，可以导出为makefile、sln等</p><h4 id="Cmake在不同平台上生成不同的本地化脚本"><a href="#Cmake在不同平台上生成不同的本地化脚本" class="headerlink" title="Cmake在不同平台上生成不同的本地化脚本"></a>Cmake在不同平台上生成不同的本地化脚本</h4><p>•Linux下的Gnu Makefile</p><p>•Visual Studio的sln</p><p>•Google等ninja</p><h4 id="Cmake管理的代码编译主要有两步："><a href="#Cmake管理的代码编译主要有两步：" class="headerlink" title="Cmake管理的代码编译主要有两步："></a>Cmake管理的代码编译主要有两步：</h4><ol><li>利用cmake生成本地编译脚本</li><li>利用本地脚本编译程序</li></ol><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>•定义工程</p><p>•设置变量</p><p>•添加可执行目标</p><p>•添加递归目录</p><p>•添加静态库、动态库</p><p>•条件分支</p><p>•定制命令和目标add_custom_command&#x2F;add_custom_target</p><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>版本控制系统（Version Control System，简称VCS）是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p><p>•本地版本控制系统</p><p>•集中化的版本控制系统</p><p>•分布式版本控制系统</p><h4 id="Git的分布式管理"><a href="#Git的分布式管理" class="headerlink" title="Git的分布式管理"></a>Git的分布式管理</h4><p><img src="/img/post/GNU%E5%B7%A5%E5%85%B7%E9%93%BE/Git%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%A1%E7%90%86.png" alt="Git的分布式管理" title="Git的分布式管理"></p><h4 id="Git的分支管理"><a href="#Git的分支管理" class="headerlink" title="Git的分支管理"></a>Git的分支管理</h4><p>围绕主干开发</p><p><img src="/img/post/GNU%E5%B7%A5%E5%85%B7%E9%93%BE/Git%E7%9A%84%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86.png" alt="Git的分支管理" title="Git的分支管理"></p><h4 id="主要命令"><a href="#主要命令" class="headerlink" title="主要命令"></a>主要命令</h4><p>•git init</p><p>•git clone</p><p>•git status</p><p>•git add</p><p>•git commit</p><p>•git log</p><p>•git fetch [remote-name]</p><p>•git push [remote-name] [branch-name]</p><p>•git branch</p><p>自己博客以前稍稍总结了下：<a href="https://sleepyfox-github.github.io/2020/10/30/git%E5%AD%A6%E4%B9%A0%E5%AF%BC%E5%BC%95/">git学习导引 | 小狐狸的被窝</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> 工具链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GNU工具链 </tag>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix通信</title>
      <link href="/2021/05/10/Unix%E9%80%9A%E4%BF%A1/"/>
      <url>/2021/05/10/Unix%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<p>Unix系统中的通信系统主要包括内部通信系统和外部通信系统两大部分:</p><p>内部通信系统：<br>  Unix系统本身自带的主要用于本机系统内部各用户之间的通信.</p><p>外部通信系统：<br>  Unix系统之外配置的通信系统，主要用于本机用户与其他主机上的<br>  用户之间的通信.</p><p>下面主要介绍Unix内部通信系统.</p><h4 id="即时通讯"><a href="#即时通讯" class="headerlink" title="即时通讯"></a>即时通讯</h4><h5 id="交谈命令"><a href="#交谈命令" class="headerlink" title="交谈命令"></a>交谈命令</h5><p>write username [terminal](终端号)<br> write命令用于与一个已经登录到系统中的用户进行通讯.<br>    如果这个登录用户的名字现在正被多个人使用，则在write<br>    命令中应给出终端号.<br>    例如：a用户向b用户发送消息:<br>    $write b<br>     Hello,b!Spring games will be taken this weekend.<br> &lt;Ctrl+D&gt;</p><p>​    Write协议：<br>​       消息发送结束用o(结束)<br>​       结束谈话用oo(结束并退出)</p><p> Write命令(半双工通信):<br>      a. 首先会检查用户是否在线上;<br>      b. 如果没有登录，屏幕会显示用户 is not logged in.<br>      c. 如果在线，则将显示登录时间.</p><h5 id="消息开关命令"><a href="#消息开关命令" class="headerlink" title="消息开关命令"></a>消息开关命令</h5><p>mesg<br>      mesg命令用于查询和开关本终端状态，命令格式为:<br>      mesg [-y] [-n]<br>    例如:<br>      $mesg       #查询本终端当前的消息接收状态<br>      is y       #可以接收消息<br>      $mesg n      #设置关闭状态<br>      $mesg y      #设置打开状态</p><h5 id="双向通信命令"><a href="#双向通信命令" class="headerlink" title="双向通信命令"></a>双向通信命令</h5><p> talk(全双工方式)<br>      与write命令相似，talk命令也是与系统中已登录的其他<br>      用户通信；与write命令不同的是，talk通信双方都必须<br>      向对方发出talk命令才能通信.</p><p>​    例如：用户a向用户b发出talk命令，则：a用户屏幕显示：<br>​      [waiting for your party to respond]<br>​    用户b屏幕显示:<br>​      Message from talk_d...@.. at 时间<br>​      talk:connection requested by …<br>​      talk:respond with:talk a<br>​    如果b用talk命令响应，此时双方的屏幕被划分成两块。</p><h5 id="广播信息命令"><a href="#广播信息命令" class="headerlink" title="广播信息命令"></a>广播信息命令</h5><p>wall<br>      wall命令可以向当前系统中所有已登录用户广播信息，常用于<br>      通知一些紧急事件.<br>      普通用户用wall发出的广播信息只能被消息状态为打开的用户<br>      接收，而超级用户用wall发信息时不受此限制.例如：</p><pre><code>  \#wall  System will be down in 10 minutes,logout please.  &lt;Ctrl+d&gt;</code></pre><h5 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h5><p>​      mail username #发送邮件<br>​      mail     #接收邮件</p><h6 id="系统邮箱"><a href="#系统邮箱" class="headerlink" title="系统邮箱"></a>系统邮箱</h6><p>​      系统邮箱在目录&#x2F;usr&#x2F;mail或&#x2F;var&#x2F;mail下，每个用户都有一个以其<br>​    名字命名的邮箱，所有发给该用户的邮件都放在该邮箱中，用户读邮件<br>​    时就从该邮箱中读取.&#x2F;var&#x2F;mail&#x2F;username</p><h6 id="个人邮箱"><a href="#个人邮箱" class="headerlink" title="个人邮箱"></a>个人邮箱</h6><p>​      个人邮箱通常为用户自己的主目录(HOME)下的mbox文件.用户读过的<br>​    邮件如果不删除或转存，则存放到个人邮箱中.&#x2F;home&#x2F;username&#x2F;mbox</p><h6 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h6><p>​      $mail username<br>​      Subject: test mail<br>​      This is the first line of mail.<br>​      This is the end line of mail.<br>​      &lt;Ctrl+d&gt;<br>​      cc:(抄送)<br>​      $<br>​      说明：接收者姓名用其login_name,即登录名；<br>​         标题和抄送可有可无，如果不需要按回车即可。<br>​         邮件正文结束，加&lt;ctrl+d&gt;<br>​      给多用户发邮件:<br>​      $mail user1,user2…(各用户名)<br>​      $mail usergroup(用户组)<br>​      $alias usr_list user1,user2…<br>​      (建立一个总的别名，该别名只能在本shell中有效，退出即无效)<br>​      $mail usr_list(给别名usr_list包括的用户都发邮件)</p><p>​      将已有文件作为邮件附件发送给用户:<br>​      $mail username &lt; my_letter<br>​      把已存在的文件my_letter作为邮件内容发送给username,该命令以<br>​      “输入重定向”方式执行，因此不需要键盘输入邮件正文.<br>​      如果发送给不存在的用户，由于没有接收方，故系统会将邮件退回<br>​      到本用户主目录下dead.letter中.</p><h6 id="接收邮件"><a href="#接收邮件" class="headerlink" title="接收邮件"></a>接收邮件</h6><p>  mail<br>      在mail命令模式下的常用命令：<br>      -——————————————————<br>      <cr>      如有下一页则显示，否则退出mail<br>      p        显示本邮件信息<br>      s file     把当前邮件保存到文件file中,如未<br>      m user     给用户usr发新邮件<br>      d        删除当前邮件<br>      n        显示下一个邮件<br>      q        退出mail,把未删除的邮件保存到个人邮箱中<br>      R        回复邮件<br>      !        执行shell命令<br>      ?        显示mail的内部命令<br>      -——————————————————</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索shell</title>
      <link href="/2021/05/03/%E6%8E%A2%E7%B4%A2shell/"/>
      <url>/2021/05/03/%E6%8E%A2%E7%B4%A2shell/</url>
      
        <content type="html"><![CDATA[<h2 id="shell工作原理"><a href="#shell工作原理" class="headerlink" title="shell工作原理"></a>shell工作原理</h2><p>&#x2F;etc&#x2F;passwd决定了用户登录后执行的shell程序。有些特殊的用户，可以不是shell程序</p><h4 id="shell解析用户命令"><a href="#shell解析用户命令" class="headerlink" title="shell解析用户命令"></a>shell解析用户命令</h4><p>•创建子进程执行用户命令</p><p>•shell等待命令子进程退出</p><p>•命令子进程退出，发送SIGCHLD信号给shell</p><p>•shell在信号处理函数中处理子进程退出</p><h4 id="shell进程退出"><a href="#shell进程退出" class="headerlink" title="shell进程退出"></a>shell进程退出</h4><p>•发送SIGCHLD信号给login进程</p><p>•login进程处理SIGCHLD信号</p><p>•退出，发送SIGCHLD信号给init进程</p><p>•init进程处理SIGCHLD信号，重新fork&#x2F;exec一个getty进程</p><p><img src="/img/post/%E6%8E%A2%E7%B4%A2shell/shell%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA.png" alt="shell进程退出" title="shell进程退出"></p><p>shell内建命令会比外部命令执行得更快，执行外部命令时不但会触发磁盘 I&#x2F;O，还需要 fork 出一个单独的进程来执行，执行完成后再退出。而执行内建命令相当于调用当前 Shell 进程的一个函数。内置命令可以替换一些经常使用的命令，部分提升性能</p><p>Special building command → function → building command → export command</p><p>•内置命令区分出special，原因是某些内置命令允许function重载</p><h4 id="echo命令输出字符串"><a href="#echo命令输出字符串" class="headerlink" title="echo命令输出字符串"></a>echo命令输出字符串</h4><p>•不同的Unix系统对echo的命令做了选项扩展</p><p>•如果是格式化输出，使用printf</p><h2 id="shell语言"><a href="#shell语言" class="headerlink" title="shell语言"></a>shell语言</h2><p>shell负责与用户交互，虽然简单，但仍然要看成一种语言</p><p>•变量</p><p>•命令</p><p>•循环与分支</p><h4 id="命令的语法"><a href="#命令的语法" class="headerlink" title="命令的语法"></a>命令的语法</h4><p>命令+空格+[选项]+参数+(;|回车)</p><p>•echo hello; ls -al</p><p>•多行单条命令，一行的尾部以\结束</p><p>•ls \</p><p>  -al</p><h4 id="完整的命令解析过程"><a href="#完整的命令解析过程" class="headerlink" title="完整的命令解析过程"></a>完整的命令解析过程</h4><p><img src="/img/post/%E6%8E%A2%E7%B4%A2shell/%E5%AE%8C%E6%95%B4%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B.png" alt="完整的命令解析过程" title="完整的命令解析过程"></p><p>•tilde是~表达式展开</p><p>•变量替换</p><p>•命令展开是重音符的命令展开</p><p>•单词划分利用$IFS变量分割</p><p>•寻找命令</p><h2 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h2><p>set命令显示所有变量，export命令显示所有环境变量</p><h4 id="shell内置一个变量表"><a href="#shell内置一个变量表" class="headerlink" title="shell内置一个变量表"></a>shell内置一个变量表</h4><p>•每个变量有环境变量或局部变量属性</p><p>•变量名 à 字符串</p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>•会将环境变量传递给子进程(fork)</p><p>•C语言getenv()函数</p><h4 id="添加修改变量"><a href="#添加修改变量" class="headerlink" title="添加修改变量"></a>添加修改变量</h4><p>•VAR&#x3D;xxx</p><p>•等号两侧不能由空格</p><p>•export VAR&#x3D;xxx添加环境变量</p><h4 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h4><p>•$VAR或者${VAR}</p><h4 id="标准变量"><a href="#标准变量" class="headerlink" title="标准变量"></a>标准变量</h4><h5 id="HOME变量"><a href="#HOME变量" class="headerlink" title="HOME变量"></a>HOME变量</h5><p>记录用户主目录</p><p>•HOME&#x3D;&#x2F;usr</p><p>•cd</p><h5 id="PATH变量"><a href="#PATH变量" class="headerlink" title="PATH变量"></a>PATH变量</h5><p>给出外部程序的搜索路径</p><p>•dash</p><p>•PATH&#x3D;</p><p>•which pwd</p><p>•exit</p><h5 id="IFS变量"><a href="#IFS变量" class="headerlink" title="IFS变量"></a>IFS变量</h5><p>定义扩展命令参数时的分隔符</p><h2 id="命令参数展开"><a href="#命令参数展开" class="headerlink" title="命令参数展开"></a>命令参数展开</h2><p>shell在解释命令时，有一个重要的步骤是展开变量得到命令参数</p><p>例：ls -al *</p><p>shell在解释这条命令时：</p><p>•ls是命令，special builtins → functions → builtins → export command去查找</p><p>•-al是一个参数</p><p>•*需要展开</p><h4 id="shell内部将对参数的展开"><a href="#shell内部将对参数的展开" class="headerlink" title="shell内部将对参数的展开"></a>shell内部将对参数的展开</h4><p>•-开头当成选项</p><p>•双引号、单引号、重音符号开头作为字符串</p><p>•$开头作为变量</p><p>•&lt;&gt;作为重定向符号</p><p>•|作为管道符号</p><p>•其余字符串如果包含*?[]需要做路径匹配展开</p><h4 id="shell路径元字符"><a href="#shell路径元字符" class="headerlink" title="shell路径元字符"></a>shell路径元字符</h4><p>！注意shell元字符并非正则表达式</p><table><thead><tr><th><strong>元字符</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>?</td><td>匹配路径名的单个字符</td></tr><tr><td>*</td><td>匹配路径名的任意长度的字符串</td></tr><tr><td>[list]</td><td>匹配list中任意一个字符</td></tr><tr><td>[!list]</td><td>匹配不在list中的任意一个字符</td></tr></tbody></table><p>例：[abc]；[a-z]；[!a-z]；[a-z!]</p><h4 id="反斜杠-转义"><a href="#反斜杠-转义" class="headerlink" title="反斜杠\转义"></a>反斜杠\转义</h4><p>消除shell元字符语义</p><p>•rm temp?</p><p>•rm temp?</p><p>•echo \&lt; \&gt; \” \’ \&#96; \$ \* ? \&amp; \| \\</p><h4 id="双引号，单引号字符串"><a href="#双引号，单引号字符串" class="headerlink" title="双引号，单引号字符串"></a>双引号，单引号字符串</h4><p>双引号字符串需要展开$VAR变量，单引号，重音符号</p><p>•echo “$HOME”</p><p>单引号字符串不展开变量</p><p>•echo ‘$HOME’</p><p>重音符号表示一个内嵌命令，要先执行，然后得到输出作为参数</p><p>•双引号内的重音符号要先执行</p><p>•echo “`ls -a`&#96;”</p><h2 id="find与grep"><a href="#find与grep" class="headerlink" title="find与grep"></a>find与grep</h2><h4 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h4><p>在文件目录树中查找文件</p><p>find start-point tests action</p><p>•从start-point开始查找，start-point是一个路径</p><p>•tests做测试</p><p>•满足条件执行action</p><h5 id="测试条件"><a href="#测试条件" class="headerlink" title="测试条件"></a>测试条件</h5><table><thead><tr><th><strong>选项</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>-name  filename</td><td>根据给定的filename做匹配查找</td></tr><tr><td>-size  +-n</td><td>查找大小为n的文件</td></tr><tr><td>-type  filetype</td><td>查找指定类型filetype的文件</td></tr><tr><td>-atime  n</td><td>查找access访问时间的问题</td></tr><tr><td>-mtime  n</td><td>查找修改时间的文件</td></tr></tbody></table><p>使用命令   find .&#x2F; -name *.sh   （本身已经在要查找的目录里了）</p><p>结果报错</p><p>解决方法一：find .&#x2F; -name \*.sh  （将.sh转义）</p><p>解决方法二：find .&#x2F; -name “*.sh”  </p><p>-type</p><p>•-type f 普通文件</p><p>•-type d 目录文件</p><h5 id="Action选项"><a href="#Action选项" class="headerlink" title="Action选项"></a>Action选项</h5><table><thead><tr><th><strong>选项</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>-print</td><td>打印输出</td></tr><tr><td>-exec  command;</td><td>执行命令</td></tr><tr><td>-ok  command;</td><td>在执行命令前要求确认</td></tr></tbody></table><h5 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h5><p>打开文件，在文件中以RE方式搜索字符串</p><p>•grep [OPTION…] PATTERNS [FILE…]</p><table><thead><tr><th><strong>短选项</strong></th><th><strong>长选项</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>-c</td><td>–count</td><td>只显示匹配的行数</td></tr><tr><td>-i</td><td>–ignore-case</td><td>忽略大小写匹配</td></tr><tr><td>-G</td><td>–basic-regexp</td><td>BRE，grep缺省</td></tr><tr><td>-E</td><td>–extended-regexp</td><td>ERE，egrep缺省</td></tr><tr><td>-e  PATTERNS</td><td>–regexp&#x3D;PATTERNS</td><td>指定一个或多个RE</td></tr><tr><td>-v</td><td>–invert-match</td><td>显示不匹配的行</td></tr><tr><td>-n</td><td>–line-number</td><td>输出行号</td></tr></tbody></table><h5 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h5><p>xargs [command [initial-arguments]]</p><p>•xargs从标准输入上读，将标准输入文件按照空格&#x2F;TAB拆解成参数，作为command执行参数。</p><p>•查找epoll_wait函数在那个文件：find &#x2F;usr&#x2F;include –name “*.h” -type f | xargs grep “epoll_wait”</p><h2 id="shell配置"><a href="#shell配置" class="headerlink" title="shell配置"></a>shell配置</h2><p>用户登录，启动缺省shell</p><p>•man bash，查找INVOCATION</p><p>•&#x2F;etc&#x2F;profile → ~&#x2F;.bash_profile → ~&#x2F;.bash_login → ~&#x2F;.profile</p><p>如果不是login启动的shell</p><p>•&#x2F;etc&#x2F;bash.bashrc → ~&#x2F;.bashrc</p><p>用户退出</p><p>•~&#x2F;.bashr_logout</p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h4 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h4><p>显示进程</p><p>•ps -ejH以树型输出所有进程</p><table><thead><tr><th><strong>选项</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>-a</td><td>显示所有进程，但不包括会话leader，不包括无终端进程</td></tr><tr><td>-f</td><td>显示进程完整信息</td></tr><tr><td>-e</td><td>显示所有进程</td></tr><tr><td>-H</td><td>按照树型显示</td></tr><tr><td>-j</td><td>按照job形式输出</td></tr></tbody></table><h4 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h4><p>向进程发送信号</p><p>•缺省发送SIGTERM信号，15</p><table><thead><tr><th><strong>选项</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>-l</td><td>列出所有信号</td></tr><tr><td>-1</td><td>除init进程，以及自己外的所有进程</td></tr><tr><td>-s</td><td>发送s标志的信号</td></tr></tbody></table><p>•信号类似于硬件中断</p><p>•Ctrl-c快捷键 → 发送SIGINT信号</p><p>•Ctrl-d → 发送EOF，意思是输入关闭</p><h4 id="trap命令"><a href="#trap命令" class="headerlink" title="trap命令"></a>trap命令</h4><p>设置进程捕获信号后如何处理</p><p>trap “command” signal numbers</p><p>•trap ‘’ TERM 忽略SIGTERM信号</p><p>•trap - TERM 恢复SIGTERM信号缺省处理</p><h2 id="前台后台"><a href="#前台后台" class="headerlink" title="前台后台"></a>前台后台</h2><h4 id="命令"><a href="#命令" class="headerlink" title="&amp;命令"></a>&amp;命令</h4><p>shell命令使用&amp;表示后台执行</p><p>•ping <a href="http://www.baidu.com/">www.baidu.com</a> &gt; &#x2F;dev&#x2F;null &amp;</p><p>•nohup “command”&amp;：后台执行命令，并且该命令在用户退出登录后仍然执行</p><h4 id="jobs命令"><a href="#jobs命令" class="headerlink" title="jobs命令"></a>jobs命令</h4><p>是一个builtin命令，列举后台执行的作业</p><p>•man bash搜索SHELL BUILTIN COMMANDS</p><h4 id="fg命令"><a href="#fg命令" class="headerlink" title="fg命令"></a>fg命令</h4><p>fg jobspec 作业编号用jobs命令查询</p><h2 id="History与fc"><a href="#History与fc" class="headerlink" title="History与fc"></a>History与fc</h2><h4 id="History"><a href="#History" class="headerlink" title="History"></a>History</h4><p>Bash在执行命令后，会在内存中记录所有使用的命令。</p><p>当用户退出登录，所有命令保存在~&#x2F;.bash_history文件中</p><p>•history命令则列出到目前为止，执行的所有命令。</p><p>•~&#x2F;.bash_history记录的是到上次退出前的所有命令，注意与history不同</p><h4 id="fc"><a href="#fc" class="headerlink" title="fc"></a>fc</h4><p>fc是一个builtin命令。man bash搜索SHELL BUILTIN COMMANDS</p><p>•fc first last ：命令先编辑从first到last的命令，然后执行</p><p>•fc –s cmd ：cmd是history的命令编号，执行该编号任务</p><h4 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h4><p>alias是一个builtin命令</p><p>•alias ll&#x3D;‘ls –al’</p><h4 id="tee命令"><a href="#tee命令" class="headerlink" title="tee命令"></a>tee命令</h4><p>分离输出，同时输出到标准输出和文件</p><p>•ls -al | tee dir.list</p><table><thead><tr><th><strong>选项</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>-a</td><td>追加到文件</td></tr><tr><td>-i</td><td>忽略中断信号</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2021/04/26/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2021/04/26/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>Unix系统偏好于以可读的文本处理</p><ul><li>vi、emacs、grep、sed、awk都支持正则表达式</li><li>systemd</li></ul><p>正则表达式RE是一种语言，这种语言表现为一种的表达式</p><p>RE可以完全的表示有限自动机DFA、NFA</p><p>RE主要用于定义词法</p><p>Posix标准中RE分为</p><ul><li>BRE</li><li>ERE</li></ul><h2 id="RE字符集"><a href="#RE字符集" class="headerlink" title="RE字符集"></a>RE字符集</h2><p>RE将字符分为普通字符和元字符</p><table><thead><tr><th><strong>字符</strong></th><th><strong>BRE&#x2F;ERE</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>\</td><td>Both</td><td>转义</td></tr><tr><td>.</td><td>Both</td><td>匹配单个字符</td></tr><tr><td>*</td><td>Both</td><td>匹配任意次，可以是0次。a*表示匹配任意多次a，.*表示任意字符串</td></tr><tr><td>^</td><td>Both</td><td>锚定匹配位置，从一行的行首开始</td></tr><tr><td>$</td><td>Both</td><td>锚定匹配位置，到一行的行尾</td></tr><tr><td>[…]</td><td>Both</td><td>匹配中括号内的某个字符。x-y表示一个范围；[^…]表示不匹配中括号中的任意字符。[开括号后跟-或]，-]转义为普通字符</td></tr><tr><td>\{n,m\}</td><td>BRE</td><td>匹配次数为[n,m]，\{n\}匹配n次，\{n,\}最小匹配次数为n</td></tr><tr><td>\(  \)</td><td>BRE</td><td>定义一个匹配位置，在后部可以引用该位置。例如，\(ab\).*\1表示ab字符串包夹了一个任意字符串。</td></tr><tr><td>\n</td><td>BRE</td><td>引用已经定义的位置，可以从\1到\9</td></tr><tr><td>{n,m}</td><td>ERE</td><td>与BRE的\{n,m\}相同</td></tr><tr><td>+</td><td>ERE</td><td>匹配至少1次</td></tr><tr><td>?</td><td>ERE</td><td>匹配0或1次</td></tr><tr><td>|</td><td>ERE</td><td>或</td></tr><tr><td>()</td><td>ERE</td><td>匹配括号内的整个字符串</td></tr></tbody></table><p>[ ]表达式是选择匹配中任意一个字符</p><ul><li>c[aeiouy]t，匹配可以是cat、cet、cot等</li><li>[0123456789]表示为[0-9]</li></ul><p>特别的</p><ul><li>[[:alnum:]] 字符+数字</li><li>[[:alpha:]] 字符</li><li>[[:digit:]] 数字</li><li>[[:lower:]] 小写字符</li><li>[[:upper:]] 大写字符</li><li>[[:space:]] 空字符：空格、tab等</li></ul><h2 id="RE例子"><a href="#RE例子" class="headerlink" title="RE例子"></a>RE例子</h2><p>[*\.], []*\.], [-*\.], []*\.-]</p><p>BRE: \(ab\)\(cd\)[def]*\2\1             abcdecdab</p><p>BRE: \(why\).*\1                           whyXXwhy</p><p>\([[:alpha:]_][[:alnum:]_]*\) &#x3D; \1                    c语言赋值语句</p><p>^ABC</p><p>Def$</p><h2 id="vi的正则表达式搜索与替换"><a href="#vi的正则表达式搜索与替换" class="headerlink" title="vi的正则表达式搜索与替换"></a>vi的正则表达式搜索与替换</h2><p>首先检查magic变量，一般是magic</p><ul><li>:set magic?</li></ul><p>&#x2F;或？</p><ul><li>后跟一个RE表达式</li></ul><h5 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h5><p>:range <strong>s</strong>&#x2F;from&#x2F;to&#x2F;flags</p><p>range表示行范围，%是全局所有行</p><ul><li>1,$表示从1行到尾行</li></ul><p>flags为g表示这一行中所有的匹配项都替换</p><p>:%s&#x2F;from&#x2F;to&#x2F;g最常用</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件系统高级操作</title>
      <link href="/2021/04/20/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C/"/>
      <url>/2021/04/20/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>C语言程序一般会打开三个缺省文件，stdin、stdout、stderr，文件描述符分别是0,1,2。</p><p>在Unix系统中，文件是io的基本抽象。标准输入、标准输出、错误输出可以替换为其它文件。</p><h4 id="标准输出重定向"><a href="#标准输出重定向" class="headerlink" title="标准输出重定向"></a>标准输出重定向</h4><ul><li>command &gt; file</li><li>command &gt;&gt; file 追加</li></ul><h4 id="标准输入重定向"><a href="#标准输入重定向" class="headerlink" title="标准输入重定向"></a>标准输入重定向</h4><ul><li>command &lt; file</li><li>command &lt;&lt; EOF 标准输入，当碰到EOF字符串时，输入结束</li></ul><h4 id="标准错误输出重定向"><a href="#标准错误输出重定向" class="headerlink" title="标准错误输出重定向"></a>标准错误输出重定向</h4><ul><li><p>command 2&gt; file 将command的错误输出重定向到file文件</p></li><li><p>command 2&gt;&gt; file 追加重定向</p></li></ul><h4 id="重定向标准输出-标准错误输出"><a href="#重定向标准输出-标准错误输出" class="headerlink" title="重定向标准输出+标准错误输出"></a>重定向标准输出+标准错误输出</h4><p>command &amp;&gt; file</p><p>command &amp;&gt;&gt; file 追加重定向</p><h4 id="特别文件"><a href="#特别文件" class="headerlink" title="特别文件"></a>特别文件</h4><p>&#x2F;dev&#x2F;null bit垃圾桶</p><p>command &gt; &#x2F;dev&#x2F;null</p><h4 id="Cat命令与重定向"><a href="#Cat命令与重定向" class="headerlink" title="Cat命令与重定向"></a>Cat命令与重定向</h4><p>cat &gt; myfirst</p><p>cat &gt;&gt; myfirst</p><p>cat myfirst &gt; mysecond</p><p>cat myfirst mysecond &gt; mythird</p><p>cat &gt; myfirst &lt;&lt; EOF</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p><img src="/img/post/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C/pipeline.png" alt="pipeline" title="pipeline"></p><p>shell将一个程序的标准输出作为另一个程序的标准输入，形成管道（pipeline）</p><ul><li>command A | command B</li><li>注意两条命令之间是以一个匿名文件传输</li><li>ls –al | grep -e “^d”</li><li>ls -al | less</li></ul><h4 id="Shell如何实现管道？"><a href="#Shell如何实现管道？" class="headerlink" title="Shell如何实现管道？"></a>Shell如何实现管道？</h4><p>•pipe()函数创建一个两个文件描述符，一个输入，一个输出</p><p>•fork</p><p>•主要的问题是：如何将父进程的标准输出替换为pipe输出，子进程的标准输入替换为pipe输入</p><p>参考：<a href="http://www.rozmichelle.com/pipes-forks-dups/">http://www.rozmichelle.com/pipes-forks-dups/</a></p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h4 id="cp拷贝源文件成目标文件"><a href="#cp拷贝源文件成目标文件" class="headerlink" title="cp拷贝源文件成目标文件"></a>cp拷贝源文件成目标文件</h4><ul><li>-b 如果目标文件存在备份~</li><li>-i 如果目标文件存在，提示</li><li>-r 递归拷贝</li></ul><h4 id="mv移动文件"><a href="#mv移动文件" class="headerlink" title="mv移动文件"></a>mv移动文件</h4><ul><li>-b 如果目标文件存在，则备份~</li><li>-i 如果目标文件存在，提示</li><li>-f 强制移动</li></ul><h4 id="wc统计字数"><a href="#wc统计字数" class="headerlink" title="wc统计字数"></a>wc统计字数</h4><table><thead><tr><th><strong>短选项</strong></th><th><strong>长选项</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>-l</td><td>–lines</td><td>统计行数</td></tr><tr><td>-w</td><td>–words</td><td>统计单词数量</td></tr><tr><td>-c</td><td>–chars</td><td>统计字符数量</td></tr><tr><td></td><td>–help</td><td>帮助</td></tr></tbody></table><h4 id="head显示文件头部"><a href="#head显示文件头部" class="headerlink" title="head显示文件头部"></a>head显示文件头部</h4><p>缺省显示头部10行</p><table><thead><tr><th><strong>短选项</strong></th><th><strong>长选项</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>-n</td><td>–lines&#x3D;n</td><td>显示头部n行</td></tr><tr><td>-c  n</td><td>–chars&#x3D;n</td><td>显示头部n个字符</td></tr><tr><td></td><td>–help</td><td>帮助</td></tr><tr><td></td><td>–version</td><td>版本号</td></tr></tbody></table><h4 id="tail显示文件尾部"><a href="#tail显示文件尾部" class="headerlink" title="tail显示文件尾部"></a>tail显示文件尾部</h4><p>缺省是尾部10行</p><table><thead><tr><th><strong>短选项</strong></th><th><strong>长选项</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>-n</td><td>–lines&#x3D;n</td><td>显示尾部n行</td></tr><tr><td>-c  n</td><td>–chars&#x3D;n</td><td>显示尾部n个字符</td></tr><tr><td></td><td>–help</td><td>帮助</td></tr><tr><td></td><td>–version</td><td>版本号</td></tr></tbody></table><h4 id="cut命令纵向输出文件的某个列"><a href="#cut命令纵向输出文件的某个列" class="headerlink" title="cut命令纵向输出文件的某个列"></a>cut命令纵向输出文件的某个列</h4><table><thead><tr><th><strong>短选项</strong></th><th><strong>长选项</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>-f  LIST</td><td>–fields&#x3D;LIST</td><td>指定剪切的域</td></tr><tr><td>-d  x</td><td>–delimiter&#x3D;x</td><td>指定域的分隔符</td></tr><tr><td>-c  LIST</td><td>–characters&#x3D;LIST</td><td>指定剪切字符位置</td></tr><tr><td></td><td>–help</td><td>帮助</td></tr></tbody></table><p>LIST为如下形式:</p><ul><li>n-m 表示[n,m]的域</li><li>n,m 表示n和m域</li></ul><p>缺省分隔符是TAB制表键</p><h4 id="paste命令横向连接两个文件"><a href="#paste命令横向连接两个文件" class="headerlink" title="paste命令横向连接两个文件"></a>paste命令横向连接两个文件</h4><table><thead><tr><th><strong>短选项</strong></th><th><strong>长选项</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>-d  x</td><td>–delimiters&#x3D;x</td><td>指定域分隔符</td></tr><tr><td></td><td>–help</td><td>帮助</td></tr></tbody></table><p>•缺省分隔符为TAB制表符</p><h4 id="more命令分页显示文件内容"><a href="#more命令分页显示文件内容" class="headerlink" title="more命令分页显示文件内容"></a>more命令分页显示文件内容</h4><p>可以向后翻，但不能向前翻。less命令是more的改进，可以向前翻</p><h4 id="sort命令排序按照行做字典序排列文件内容"><a href="#sort命令排序按照行做字典序排列文件内容" class="headerlink" title="sort命令排序按照行做字典序排列文件内容"></a>sort命令排序按照行做字典序排列文件内容</h4><table><thead><tr><th><strong>选项</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>-b</td><td>忽略行首的空格</td></tr><tr><td>-d</td><td>在字典序比较中，忽略标点符号和控制符号</td></tr><tr><td>-t</td><td>指定域分隔符</td></tr><tr><td>-n</td><td>数字以数值排序</td></tr><tr><td>-r</td><td>逆序排列</td></tr><tr><td>-o</td><td>指定输出文件</td></tr></tbody></table><p>按照字典序，大写字母比小写字母更靠前</p><p>sort &#x2F;etc&#x2F;passwd</p><p>按照uid排列所有用户</p><p>sort -t : -n +2 &#x2F;etc&#x2F;passwd</p><h4 id="grep命令搜索字符串"><a href="#grep命令搜索字符串" class="headerlink" title="grep命令搜索字符串"></a>grep命令搜索字符串</h4><p>打开文件，在文件中以RE方式搜索字符串:grep [OPTION…] PATTERNS [FILE…]</p><table><thead><tr><th><strong>短选项</strong></th><th><strong>长选项</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>-c</td><td>–count</td><td>只显示匹配的行数</td></tr><tr><td>-i</td><td>–ignore-case</td><td>忽略大小写匹配</td></tr><tr><td>-G</td><td>–basic-regexp</td><td>BRE，grep缺省</td></tr><tr><td>-E</td><td>–extended-regexp</td><td>ERE，egrep缺省</td></tr><tr><td>-e  PATTERNS</td><td>–regexp&#x3D;PATTERNS</td><td>指定一个或多个RE</td></tr><tr><td>-v</td><td>–invert-match</td><td>显示不匹配的行</td></tr><tr><td>-n</td><td>–line-number</td><td>输出行号</td></tr></tbody></table><h4 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h4><p>•xargs [command [initial-arguments]]</p><p>•xargs从标准输入上读，将标准输入文件按照空格&#x2F;TAB拆解成参数，作为command执行参数。</p><p>查找epoll_wait函数在那个文件：find &#x2F;usr&#x2F;include –name “*.h” -type f | xargs grep “epoll_wait”</p><h2 id="文件系统原理"><a href="#文件系统原理" class="headerlink" title="文件系统原理"></a>文件系统原理</h2><h4 id="Unix三大抽象"><a href="#Unix三大抽象" class="headerlink" title="Unix三大抽象"></a>Unix三大抽象</h4><ul><li>进程、线程对执行过程</li><li>文件对io</li><li>地址空间对内存</li></ul><h4 id="Unix四种io"><a href="#Unix四种io" class="headerlink" title="Unix四种io"></a>Unix四种io</h4><p>文件系统、块设备、字符设备、socket</p><ul><li>块设备和字符设备出现在文件系统的名字空间</li><li>Socket仅表现为文件</li></ul><h4 id="Unix文件系统"><a href="#Unix文件系统" class="headerlink" title="Unix文件系统"></a>Unix文件系统</h4><p>堆+索引</p><p>•索引 key→value，key是文件名，要求变长，</p><p>•inode叫做索引节点号，这是Linux文件系统管理文件的方式。在建立文件系统时，会建立一个索引节点表，里面包含一定数量的索引节点。每当建立一个文件时，就会为他分配一个索引节点号，相当于文件的地址。</p><p><img src="/img/post/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C/%E5%85%B8%E5%9E%8BUnix%E7%A3%81%E7%9B%98%E5%B8%83%E5%B1%80.png" alt="典型Unix磁盘布局" title="典型Unix磁盘布局"></p><p>目录文件→i-node → data；ls –i显示节点</p><p><img src="/img/post/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C/inode.png" alt="inode" title="inode"></p><h5 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h5><p>ln [OPTION]… [-T] TARGET LINK_NAME</p><ul><li>ln命令不会创建新的i-node，而是引用已有i-node，增加引用计数，与普通文件没什么不同</li><li>ln –s符号链接，分配一个新的inode，内部记录指向原有文件，类似于Windows的快捷方式</li></ul><p>软连接（符号链接）与硬连接的应用场景：</p><ul><li><strong>硬链接</strong>：防止因为误操作而错误删除文件</li><li><strong>符号链接</strong>：方便管理；解决文件系统磁盘空间不足的情况</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix文件系统</title>
      <link href="/2021/04/12/Unix%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2021/04/12/Unix%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="磁盘与文件"><a href="#磁盘与文件" class="headerlink" title="磁盘与文件"></a>磁盘与文件</h2><p>磁盘上的数据以文件的形式组织</p><p>文件是操作系统对io设备的一个抽象，进程&#x2F;线程是对执行过程的抽象</p><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><ul><li>普通文件：文本、脚本、程序等</li><li>目录文件，目录以树的形式组织文件，其本身是一个文件</li><li>特殊文件，io设备等</li></ul><h4 id="Unix系统重要的目录"><a href="#Unix系统重要的目录" class="headerlink" title="Unix系统重要的目录"></a>Unix系统重要的目录</h4><p>&#x2F; 根目录</p><p>&#x2F;usr 用户目录</p><ul><li>&#x2F;usr&#x2F;include 各种库头文件位置</li><li>&#x2F;usr&#x2F;bin 用户可执行文件</li><li>&#x2F;usr&#x2F;local 自行编译安装目录</li></ul><p>&#x2F;root 管理员目录</p><p>&#x2F;boot 自举目录</p><p>&#x2F;bin 可执行程序</p><p>&#x2F;dev 设备文件</p><p>&#x2F;sbin 管理程序目录</p><p>&#x2F;etc 配置文件目录</p><p>&#x2F;home 用户目录</p><p>&#x2F;var 经常变动的文件，例如数据库、日志等</p><h4 id="几个重要的目录概念"><a href="#几个重要的目录概念" class="headerlink" title="几个重要的目录概念"></a>几个重要的目录概念</h4><p>HOME目录</p><p>工作目录</p><p>.当前目录</p><p>..父目录</p><h4 id="路径名"><a href="#路径名" class="headerlink" title="路径名"></a>路径名</h4><p>访问一个文件，使用路径</p><p>Unix的路径使用&#x2F;将目录与文件名隔开，与dos路径不同</p><p>绝对路径，以&#x2F;开头的目录</p><p>相对路径，反之则为相对路径</p><h4 id="文件命名规范"><a href="#文件命名规范" class="headerlink" title="文件命名规范"></a>文件命名规范</h4><p>避免使用：&lt;&gt;，()，[]，{}，*，?，“，‘，-，$，^</p><p>这些符号是正则表达式使用的</p><p>大小写敏感</p><p>使用扩展名提升可读性</p><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><p>pwd打印当前工作目录</p><p>cd改变当前工作目录</p><ul><li>cd</li><li>cd 路径</li></ul><p>mkdir创建目录</p><ul><li>mkdir 路径</li><li>mkdir -p 路径</li></ul><p>rmdir删除空目录：非空目录无法删除文件操作</p><p>ls打印当前目录下的子目录及文件</p><table><thead><tr><th><strong>短选项</strong></th><th><strong>长选项</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>-a</td><td>–all</td><td>列出所有文件，包括隐藏文件</td></tr><tr><td>-C</td><td>–format&#x3D;vertical  –format&#x3D;horizontal</td><td>用多列方式列出文件，按列排列</td></tr><tr><td>-F</td><td>–classify</td><td>将子目录与普通文件类型分开，子目录加&#x2F;，可执行文件加*</td></tr><tr><td>-l</td><td>–format&#x3D;single-column</td><td>详细列出文件的属性，每行一个文件</td></tr><tr><td>-m</td><td>–format&#x3D;commas</td><td>按页宽列出文件，用逗号隔开</td></tr><tr><td>-p</td><td></td><td>在目录文件名后加</td></tr><tr><td>-r</td><td>–reverse</td><td>以反字母顺序列出文件</td></tr><tr><td>-R</td><td>–recursive</td><td>递归列出子目录的内容</td></tr><tr><td>-s</td><td>–size</td><td>以block为单位列出文件大小</td></tr><tr><td>-x</td><td>–format&#x3D;horizontal  –format&#x3D;across</td><td>以多列方式列出文件，按行排列</td></tr><tr><td></td><td>–help</td><td>显示帮助信息</td></tr></tbody></table><h5 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h5><ul><li>- 表示普通文件</li><li>d 表示目录</li><li>c 表示字符设备</li><li>b 表示块设备</li><li>l 表示符号连接</li></ul><h5 id="rwx"><a href="#rwx" class="headerlink" title="rwx"></a>rwx</h5><ul><li>r 表示读权限</li><li>w 表示写权限</li><li>x 表示执行权限，对目录是访问权限</li></ul><p>3个rwx表示：拥有者自己的权限、组权限、其它人的权限</p><h5 id="隐藏文件"><a href="#隐藏文件" class="headerlink" title="隐藏文件"></a>隐藏文件</h5><ul><li>以.点开头的文件或目录是缺省不被显示</li><li>.表示当前目录</li><li>..表示父目录</li></ul><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>cat查看文件内容</p><p>touch创建一个空文件</p><p>rm删除文件</p><ul><li>rm –fr递归删除文件及目录</li><li>rm –i确认删除</li><li>特别注意：rm -fr不会让你确认删除</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vi高级用法</title>
      <link href="/2021/04/02/vi%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
      <url>/2021/04/02/vi%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="vi启动选项"><a href="#vi启动选项" class="headerlink" title="vi启动选项"></a>vi启动选项</h2><p>vi -R以只读方式打开文件</p><ul><li>:wq!强制写</li></ul><p>view只读打开文件</p><h2 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h2><p>vim内部每个buffer打开一个文件，多个buffer可以打开同一个文件</p><p>可以只有一个窗口，也可以有多个tab标签</p><p>每个tab对应一个buffer，一个buffer可以对应多个tab</p><p><img src="/img/post/vi%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/%E5%8D%95%E4%B8%AA%E7%AA%97%E5%8F%A3.png" alt="单个窗口" title="单个窗口"></p><p><img src="/img/post/vi%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/%E5%A4%9A%E4%B8%AAtab.png" alt="多个tab" title="多个tab"></p><p>这里描述的vim使用方式，是希望能在vim中完成大多数工作，而不是频繁的退出vim</p><ul><li>首先:tabnew创建一个标签</li><li>然后:e打开一个文件</li><li>:tabnext在窗口上打开下一个tab</li><li>:tabprevious在窗口上打开前一个tab</li><li>:q或者:tabclose关闭tab</li></ul><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>vim中设计了特别的暂存机制——寄存器，用于保存拷贝和删除的文本</p><p>在命令模式下以”双引号开头引用这些寄存器</p><p>命令行模式:registers显示寄存器</p><h5 id="有名寄存器"><a href="#有名寄存器" class="headerlink" title="有名寄存器"></a>有名寄存器</h5><p>a-z，一共26个，供用户使用</p><h5 id="编号寄存器"><a href="#编号寄存器" class="headerlink" title="编号寄存器"></a>编号寄存器</h5><p>0-9，10个，vim自己使用，存放删除和拷贝的文本</p><ul><li>“0号寄存器是visual模式下拷贝的问题</li><li>“1-”9号寄存器是dd删除、yy拷贝的行文本</li></ul><h5 id="缺省寄存器"><a href="#缺省寄存器" class="headerlink" title="缺省寄存器"></a>缺省寄存器</h5><ul><li>% 当前窗口对应的文件名</li><li># 当前窗口的其它文件名</li><li>: 命令行模式最近输入的命令</li><li>. 最近插入的文本</li><li>“ 最近删除或拷贝的文本</li></ul><h2 id="剪切与粘贴"><a href="#剪切与粘贴" class="headerlink" title="剪切与粘贴"></a>剪切与粘贴</h2><p>以寄存器作为剪贴板，vim的剪切与粘贴非常灵活</p><h5 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h5><ul><li>dd命令将删除行拷贝到””和”1寄存器，并且下压2-9号寄存器</li><li>yy命令将拷贝行复制到””和”0寄存器</li><li>p命令将缺省寄存器””内容拷贝到光标位置之后</li><li>P命令将缺省寄存器””内容拷贝到光标位置之前</li></ul><h5 id="Visual模式"><a href="#Visual模式" class="headerlink" title="Visual模式"></a>Visual模式</h5><ul><li>命令模式下v进入visual模式</li><li>khjl或方向键移动光标</li><li>y命令将选择内容拷贝到””和”0寄存器，y表示yank</li></ul><h2 id="Motion与range"><a href="#Motion与range" class="headerlink" title="Motion与range"></a>Motion与range</h2><p>motion是指移动光标的命令</p><p>拷贝与删除命令可与motion组合</p><ul><li>命令&#x3D;操作符+motion</li><li>y$,d0</li></ul><table><thead><tr><th><strong>motion</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>$</td><td>从光标到行尾</td></tr><tr><td>0</td><td>从光标到行首</td></tr><tr><td>e或w</td><td>从光标到字尾</td></tr><tr><td>b</td><td>从光标到字首</td></tr></tbody></table><p>range是指行数</p><p>寄存器+[range]+d&#x2F;y+[motion]组合，完成拷贝删除动作→寄存器</p><ul><li>“wdd 删除当前行到”w寄存器</li><li>“z7yy 拷贝从当前光标开始算，一共7行，到”z寄存器</li></ul><p>寄存器+p，将寄存器内容拷贝到光标后的位置上，完成寄存器→缓冲动作</p><h2 id="光标快速定位"><a href="#光标快速定位" class="headerlink" title="光标快速定位"></a>光标快速定位</h2><p>:n定位到第n行</p><p>:0或:1定位到第1行的行首</p><p>:$定位到最后一行的行尾</p><p>1G定位到第1行的行首</p><p>G或0G定位到最后一行的行首</p><p>nG定位到第n行的行首</p><p>Ctrl-g在命令行区域输出当前行号</p><p>Ctrl-End跳到最后一个字符或者G$</p><h2 id="vim定制"><a href="#vim定制" class="headerlink" title="vim定制"></a>vim定制</h2><p>让vim更舒服一些，修改.exrc或者.vimrc</p><p>:set命令</p><ul><li>:set all 显示所有选项</li><li>:set 显示被修改的选项</li><li>:set X? 显示选项X的值</li></ul><h2 id="执行shell命令"><a href="#执行shell命令" class="headerlink" title="执行shell命令"></a>执行shell命令</h2><p>:shell命令切换到shell，exit回到vim</p><p>:!命令，执行shell命令</p><p>:r!命令，将shell命令输出粘贴到当前位置</p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><h5 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h5><p>set foldenable<br> set foldmethod&#x3D;indent</p><ul><li>zc 关闭折叠</li><li>zo 打开折叠</li></ul><h5 id="设置交换文件目录"><a href="#设置交换文件目录" class="headerlink" title="设置交换文件目录"></a>设置交换文件目录</h5><p>set directory^&#x3D;$HOME&#x2F;.vim&#x2F;swap&#x2F;&#x2F;</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vi编辑器入门</title>
      <link href="/2021/03/25/vi%E7%BC%96%E8%BE%91%E5%99%A8%E5%85%A5%E9%97%A8/"/>
      <url>/2021/03/25/vi%E7%BC%96%E8%BE%91%E5%99%A8%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h2><p>编辑器是用于制作文档或者文本的程序</p><ul><li>word</li><li>vscode&#x2F;sublime&#x2F;atom</li></ul><p>文本编辑器可读文本，包括程序源代码、markdown、txt文档、脚本等</p><ul><li>图形化文本编辑器</li><li>字符界面文本编辑器:vi&#x2F;vim,emacs,nano</li></ul><h2 id="vi编辑器"><a href="#vi编辑器" class="headerlink" title="vi编辑器"></a>vi编辑器</h2><p>vi编辑器是全屏字符界面编辑器</p><p>vi&#x2F;view两个程序，view是只读程序</p><h4 id="vi工作模式"><a href="#vi工作模式" class="headerlink" title="vi工作模式"></a>vi工作模式</h4><ul><li>命令模式</li><li>插入模式</li><li>命令行模式</li><li>visual模式</li></ul><h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h4><p>su</p><p>apt install vim</p><h4 id="启动-退出vi"><a href="#启动-退出vi" class="headerlink" title="启动&#x2F;退出vi"></a>启动&#x2F;退出vi</h4><ul><li>启动后进入命令模式</li><li>命令行模式下:q!退出</li></ul><h4 id="vi的模式切换"><a href="#vi的模式切换" class="headerlink" title="vi的模式切换"></a>vi的模式切换</h4><p><img src="/img/post/vi%E7%BC%96%E8%BE%91%E5%99%A8%E5%85%A5%E9%97%A8/vi%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2.png" alt="vi的模式切换" title="vi的模式切换"></p><p>•默认进入命令模式</p><p>•按:进入命令行模式</p><p>•从输入模式返回命令模式的命令键： ESC</p><h2 id="vi编辑器基本命令"><a href="#vi编辑器基本命令" class="headerlink" title="vi编辑器基本命令"></a>vi编辑器基本命令</h2><h4 id="创建或编辑一个文件"><a href="#创建或编辑一个文件" class="headerlink" title="创建或编辑一个文件"></a>创建或编辑一个文件</h4><p>vi test.txt(文件名可以随意，并且后缀名不是必须的)</p><p>按下键盘上的“i”键，进入编辑状态。</p><h4 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h4><h5 id="键盘方向键移动光标"><a href="#键盘方向键移动光标" class="headerlink" title="键盘方向键移动光标"></a>键盘方向键移动光标</h5><h5 id="命令模式下移动光标"><a href="#命令模式下移动光标" class="headerlink" title="命令模式下移动光标"></a>命令模式下移动光标</h5><ul><li><p>:help → usr_02.txt The first steps in Vim → Ctrl-]</p></li><li><p>h表示向西&#x2F;左</p></li><li><p>j表示向南&#x2F;下</p></li><li><p>k表示向北&#x2F;上</p></li><li><p>l表示向东&#x2F;右</p></li><li><p>0或^移动光标到行首</p></li><li><p>$移动光标到行尾</p></li><li><p>w向后移动一个word</p></li><li><p>b向前移动光标到word的开头</p></li><li><p>e移动光标到word的尾部</p></li><li><p>[space]向后移动光标一格</p></li><li><p>[return]光标移动到下一行的行首</p></li><li><p>[backspace]光标向前移动一格</p></li></ul><h4 id="插入文本"><a href="#插入文本" class="headerlink" title="插入文本"></a>插入文本</h4><p>在命令模式下，输入i,I,a,A,o,O字符切换到输入模式</p><table><thead><tr><th><strong>命令</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>i</td><td>在光标左侧插入</td></tr><tr><td>I</td><td>在光标所在行的开头插入</td></tr><tr><td>a</td><td>在光标右侧插入</td></tr><tr><td>A</td><td>在光标所在行的末尾插入</td></tr><tr><td>o</td><td>在光标所在行的下一行增添新行，并且光标位于新行的开头</td></tr><tr><td>O</td><td>在光标所在行的上一行增添新行，并且光标位于新行的开头</td></tr></tbody></table><h4 id="文本修改"><a href="#文本修改" class="headerlink" title="文本修改"></a>文本修改</h4><p>在命令模式下，如下命令可以修改文本</p><table><thead><tr><th><strong>命令</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>x</td><td>删除光标所在字符</td></tr><tr><td>dd</td><td>删除光标所在行</td></tr><tr><td>u</td><td>撤销最近修改</td></tr><tr><td>U</td><td>撤销当前行的所有修改</td></tr><tr><td>r</td><td>替换光标所在字符</td></tr><tr><td>R</td><td>替换从光标开始的字符，同时进入输入模式</td></tr><tr><td>.</td><td>重复上一次的修改</td></tr></tbody></table><h4 id="搜索文本"><a href="#搜索文本" class="headerlink" title="搜索文本"></a>搜索文本</h4><p>在命令模式下：</p><ul><li>&#x2F;向后搜索</li><li>?向前搜索</li><li>n按照&#x2F;或?的方向搜索下一个匹配项</li></ul><h4 id="保存文本"><a href="#保存文本" class="headerlink" title="保存文本"></a>保存文本</h4><table><thead><tr><th align="left">:</th><th>进入命令行模式</th></tr></thead><tbody><tr><td align="left">:wq</td><td>保存并退出</td></tr><tr><td align="left">:q</td><td>退出*</td></tr><tr><td align="left">:q!</td><td>强制退出</td></tr></tbody></table><h4 id="help"><a href="#help" class="headerlink" title="help"></a>help</h4><p>命令行模式:help进入帮助模式</p><ul><li>:help x搜索命令模式下x命令</li><li>:helpgrep以grep方式搜索</li></ul><p>vimtutor</p><h2 id="vi缓冲原理"><a href="#vi缓冲原理" class="headerlink" title="vi缓冲原理"></a>vi缓冲原理</h2><h4 id="vi的缓冲模型"><a href="#vi的缓冲模型" class="headerlink" title="vi的缓冲模型"></a>vi的缓冲模型</h4><p>•vi将文件从磁盘调入内存缓冲</p><p>•只显示一个页面大小</p><p>•存在一个修改队列</p><ol><li>每次进入文本模式记录为1项</li><li>命令将最后一次修改append到队列</li><li>u命令回退这个队列</li></ol><p><img src="/img/post/vi%E7%BC%96%E8%BE%91%E5%99%A8%E5%85%A5%E9%97%A8/vi%E7%9A%84%E7%BC%93%E5%86%B2%E6%A8%A1%E5%9E%8B.png" alt="vi的缓冲模型" title="vi的缓冲模型"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix入门</title>
      <link href="/2021/03/20/Unix%E5%85%A5%E9%97%A8/"/>
      <url>/2021/03/20/Unix%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="登录与退出"><a href="#登录与退出" class="headerlink" title="登录与退出"></a>登录与退出</h2><h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>输入用户名、口令登录Unix系统。分为<strong>超级用户登录</strong>和<strong>普通用户登录</strong>。</p><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><p>在shell提示符下，键入exit命令或组合键ctrl-d。</p><h2 id="常见命令格式"><a href="#常见命令格式" class="headerlink" title="常见命令格式"></a>常见命令格式</h2><p>Unix下命令格式基本如下：</p><p> $&gt; 命令名 [-选项] [参数]</p><h5 id="命令名"><a href="#命令名" class="headerlink" title="命令名"></a>命令名</h5><ul><li>一个可执行程序</li><li>脚本程序</li><li>shell内置程序</li></ul><h5 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h5><ul><li>短选项：-单个减号，后跟一个字符</li><li>长选项：–两个减号，后跟一个单词</li></ul><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ol><li><p>显示系统的时间(date) </p></li><li><p>显示文件&#x2F;etc&#x2F;passwd中一共有多少行(wc -l &#x2F;etc&#x2F;passwd) </p><p>passwd命令用来更改使用者的密码</p></li><li><p>显示2002年的全年的日历 (cal 2021)</p></li><li><p>显示1752年9月的月历，请注意这个月的月历是否有些特别。(cal -m 9f 1752)</p></li><li><p>显示1999年1月与99年1月的月历。1999年与99年是同一年吗？ </p><p>(cal -m lf 1999；cal -m 1f 99；不是同一年)</p></li><li><p>有两个命令是用来显示当前系统中的用户情况的。用这两个命令显示现在有<br>哪些人已经登录到系统中，并查看他们是何时登录进入系统的。</p><p>(who；users)</p><ul><li>-H 或 –heading：显示用户信息及各列的标题；</li><li>-m：此参数的效果和指定”am i”字符串相同；</li><li>-q 或–count：只显示登入系统的帐号名称和总人数；</li></ul></li><li><p>只显示用户自己的登录名。(who am i)</p></li><li><p>使用 clear 命令，清屏。</p></li></ol><h2 id="man命令"><a href="#man命令" class="headerlink" title="man命令"></a>man命令</h2><h4 id="查看帮助命令"><a href="#查看帮助命令" class="headerlink" title="查看帮助命令"></a>查看帮助命令</h4><p>在命令行终端中输入man man命令来查看man命令自身的帮助信息</p><h4 id="man命令中常用按键以及用途"><a href="#man命令中常用按键以及用途" class="headerlink" title="man命令中常用按键以及用途"></a>man命令中常用按键以及用途</h4><table><thead><tr><th>按键</th><th>用途</th></tr></thead><tbody><tr><td>空格键</td><td>向下翻一页</td></tr><tr><td>PaGe down</td><td>向下翻一页</td></tr><tr><td>PaGe up</td><td>向上翻一页</td></tr><tr><td>home</td><td>直接前往首页</td></tr><tr><td>end</td><td>直接前往尾页</td></tr><tr><td>&#x2F;</td><td>从上至下搜索某个关键词，如“&#x2F;linux”</td></tr><tr><td>?</td><td>从下至上搜索某个关键词，如“?linux”</td></tr><tr><td>n</td><td>定位到下一个搜索到的关键词</td></tr><tr><td>N</td><td>定位到上一个搜索到的关键词</td></tr><tr><td>q</td><td>退出帮助文档</td></tr></tbody></table><h4 id="man命令帮助信息的结构以及意义"><a href="#man命令帮助信息的结构以及意义" class="headerlink" title="man命令帮助信息的结构以及意义"></a>man命令帮助信息的结构以及意义</h4><table><thead><tr><th>结构名称</th><th>代表意义</th></tr></thead><tbody><tr><td>NAME</td><td>命令的名称</td></tr><tr><td>SYNOPSIS</td><td>参数的大致使用方法</td></tr><tr><td>DESCRIPTION</td><td>介绍说明</td></tr><tr><td>EXAMPLES</td><td>演示（附带简单说明）</td></tr><tr><td>OVERVIEW</td><td>概述</td></tr><tr><td>DEFAULTS</td><td>默认的功能</td></tr><tr><td>OPTIONS</td><td>具体的可用选项（带介绍）</td></tr><tr><td>ENVIRONMENT</td><td>环境变量</td></tr><tr><td>FILES</td><td>用到的文件</td></tr><tr><td>SEE ALSO</td><td>相关的资料</td></tr><tr><td>HISTORY</td><td>维护历史与联系方式</td></tr></tbody></table><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>字符界面下，用户登录系统后，由shell负责与用户交互</p><p>交互的方式是提示用户输入命令</p><h5 id="shell的种类"><a href="#shell的种类" class="headerlink" title="shell的种类"></a>shell的种类</h5><ul><li>sh</li><li>ksh</li><li>csh</li><li>bash</li><li>dash</li></ul><h5 id="切换shell"><a href="#切换shell" class="headerlink" title="切换shell"></a>切换shell</h5><ul><li><p>dash</p></li><li><p>chsh改变登录的缺省shell。用户的相关信息记录在&#x2F;etc&#x2F;passwd，包括缺省shell</p><p>lcat &#x2F;etc&#x2F;passwd</p></li></ul><h5 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h5><ul><li>Ctrl-d，退出系统</li><li>Ctrl-h，退格</li><li>Ctrl-u，删除输入行</li><li>Ctrl-c，中断程序执行</li></ul><h2 id="登录退出过程解析"><a href="#登录退出过程解析" class="headerlink" title="登录退出过程解析"></a>登录退出过程解析</h2><p>Unix系统启动后，init&#x2F;systemd进程负责拉起所有用户进程</p><p>man ps</p><p>ps -ejH</p><p>systemd&#x3D;init（pid&#x3D;1）</p><h5 id="登录-1"><a href="#登录-1" class="headerlink" title="登录"></a>登录</h5><p>init进程创建getty进程守候在各个终端上</p><p>当终端上有字符输入，exec login程序</p><p>当username，password验证成功，fork一个shell进程</p><h5 id="退出-1"><a href="#退出-1" class="headerlink" title="退出"></a>退出</h5><p>shell退出、login退出</p><p>init回收login</p><p>init再fork一个新的getty进程</p><p><img src="/img/post/Unix%E5%85%A5%E9%97%A8/%E7%99%BB%E5%BD%95%E9%80%80%E5%87%BA%E8%BF%87%E7%A8%8B.png" alt="登录退出过程" title="登录退出过程"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix简史</title>
      <link href="/2021/03/15/Unix%E7%AE%80%E5%8F%B2/"/>
      <url>/2021/03/15/Unix%E7%AE%80%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机主板及结构"><a href="#计算机主板及结构" class="headerlink" title="计算机主板及结构"></a>计算机主板及结构</h2><p>计算机主板，又叫主机板，它安装在机箱内，是计算机最基本的也是最重要的部件之一。 主板一般为矩形电路板，上面安装了组成计算机的主要电路系统，一般有BIOS芯片、I&#x2F;O背板接口、键盘和面板控制开关接口、内存插槽、CMOS电池、南北桥芯片、PCI插槽等。</p><p><img src="/img/post/Unix%E7%AE%80%E5%8F%B2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%BB%E6%9D%BF%E7%9A%84%E7%BB%84%E6%88%90.png" alt="计算机主板的组成" title="计算机主板的组成"></p><h2 id="Unix操作系统发展历史"><a href="#Unix操作系统发展历史" class="headerlink" title="Unix操作系统发展历史"></a>Unix操作系统发展历史</h2><p>l1965年，由AT&amp;T，MIT和GE联合开发Multics (Multiplexed Information and Computing Service)； </p><p>l1969年，Ken Thompson 和 Dennis Ritchie在PDP-7 上用汇编语言开发出UNIX(太空旅行的游戏)；</p><p>l1970年，在PDP-11系列机上(11&#x2F;20，11&#x2F;40，11&#x2F;45)用汇编开发出UNIX v.1。在此过程中，机器的硬件逐渐复杂，UNIX所支持的特征也不断丰富，增加了文字处理程序；</p><p>l1975年，发表UNIX v.6 并广泛扩散到大学和科研单位, 为后期发展奠定了良好的基础</p><p>l1979年，优化后发布UNIX v.7——UNIX的第一个商业版本——我国开始研究应用的最早版本；</p><p>l1982年，AT&amp;T发布UNIX System III，完全转向为社会提供的商品软件；</p><p>l1983年，AT&amp;T发布UNIX System V，系统功能已趋于稳定和完善。此后System V又有一系列的公布号: 1.0&#x2F;2.0&#x2F;2.3&#x2F;3.5&#x2F;4.0&#x2F;4.2等, 现在最后版本为 System V Release 4 (SVR4)</p><h4 id="目前两大主流"><a href="#目前两大主流" class="headerlink" title="目前两大主流"></a>目前两大主流</h4><p>BSD Unix和AT&amp;T的Unix System V形成了当今Unix的两大主流</p><ul><li>BSD Unix在学术界（Berkeley UNIX ）</li><li>System V在工业界（AT&amp;T UNIX系统V）</li></ul><p>UNIX系统V：1983年AT&amp;T发布标准的UNIX系统V，商业应用的主流</p><p>Berkeley UNIX：70年代末Berkeley的CSRG使用Unix对操作系统进行研究，提出BSD 版本, 主要用于工程设计和科学计算</p><h4 id="AIX"><a href="#AIX" class="headerlink" title="AIX"></a>AIX</h4><p>IBM公司的UNIX操作系统版本，与SVR4相似，针对IBM的机器进行了优化和增强。</p><h4 id="HP-UX"><a href="#HP-UX" class="headerlink" title="HP-UX"></a>HP-UX</h4><p>惠普公司的UNIX操作系统版本，为在惠普计算机和工作站上使用和开发的。</p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><ul><li>Linux由芬兰赫尔辛基大学的Linus Torvalds创建</li><li>1991年10月，Linux第一个公开版0.02版发布</li><li>l994年3月，Linux 1.0版发布 </li><li>Linux的标志是可爱的企鹅，取自芬兰的吉祥物</li></ul><h4 id="Solaris"><a href="#Solaris" class="headerlink" title="Solaris"></a>Solaris</h4><p>Solaris是Sun公司基于UNIX系统V第2版和BSD 4.3开发的操作系统，现在的版本是Solaris2.4。</p><h4 id="UnixWare"><a href="#UnixWare" class="headerlink" title="UnixWare"></a>UnixWare</h4><p>UnixWare最早是由Novell公司开发，现在由SCO公司提供，包括两个版本: UnixWare个人版和UnixWare服务器版</p><p><img src="/img/post/Unix%E7%AE%80%E5%8F%B2/Unix%E5%8F%91%E5%B1%95%E7%BA%BF.png" alt="Unix发展线" title="Unix发展线"></p><h2 id="Unix操作系统特性"><a href="#Unix操作系统特性" class="headerlink" title="Unix操作系统特性"></a>Unix操作系统特性</h2><h4 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h4><p>可运行各种类型的计算机上，支持不同的硬件</p><h4 id="多用户性能"><a href="#多用户性能" class="headerlink" title="多用户性能"></a>多用户性能</h4><p>多个用户同时共享计算机资源</p><h4 id="多任务性能"><a href="#多任务性能" class="headerlink" title="多任务性能"></a>多任务性能</h4><p>允许多个任务同时运行，前台、后台</p><h4 id="分级文件系统"><a href="#分级文件系统" class="headerlink" title="分级文件系统"></a>分级文件系统</h4><p>采用树状目录组织文件，顶级是&#x2F;目录</p><h4 id="与设备独立的输入和输出操作"><a href="#与设备独立的输入和输出操作" class="headerlink" title="与设备独立的输入和输出操作"></a>与设备独立的输入和输出操作</h4><p>UNIX将所有设备作为文件进行处理，对于所有设备采用通用的输入、输出命令（含重定向）</p><h4 id="用户界面：shell"><a href="#用户界面：shell" class="headerlink" title="用户界面：shell"></a>用户界面：shell</h4><ul><li>Shell是用户与系统的接口，shell还是一种命令解释程序</li><li>Shell脚本，若干命令组成的文件</li></ul><h4 id="系统工具"><a href="#系统工具" class="headerlink" title="系统工具"></a>系统工具</h4><p>文本编辑工具、系统管理工具等</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切片</title>
      <link href="/2021/02/09/%E5%88%87%E7%89%87/"/>
      <url>/2021/02/09/%E5%88%87%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h6 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h6><p>Python中将处理列表的部分元素称之为切片。要创建切片，可指定要使用的第一个元素的索引和最后一个元素的索引加1，比如，要输出列表中的前三个元素，需要指定索引0-3，分别输出0、1、2的元素。</p><p>例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">players =[<span class="string">&#x27;charles&#x27;</span>,<span class="string">&#x27;martina&#x27;</span>,<span class="string">&#x27;michael&#x27;</span>,<span class="string">&#x27;florence&#x27;</span>,<span class="string">&#x27;eli&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(players[<span class="number">0</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>代码打印该列表的一个切片，其中包含三名队员。</p><p>也可以生成列表的任何子集，例如提取列表的2-4个元素，可将起始索引的值指定为1，将终止索引指定为4</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">players =[<span class="string">&#x27;charles&#x27;</span>,<span class="string">&#x27;martina&#x27;</span>,<span class="string">&#x27;michael&#x27;</span>,<span class="string">&#x27;florence&#x27;</span>,<span class="string">&#x27;eli&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(players[<span class="number">1</span>:<span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>如果没有指定起始索引，Python将自动从列表头开始</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">players =[<span class="string">&#x27;charles&#x27;</span>,<span class="string">&#x27;martina&#x27;</span>,<span class="string">&#x27;michael&#x27;</span>,<span class="string">&#x27;florence&#x27;</span>,<span class="string">&#x27;eli&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(players[:<span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>要让切片终止于列表的末尾，可以使用类似的语法。例如，提取从第三个元素到列表末尾的所有元素，可将起始索引设置为2，省略终止索引</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">players =[<span class="string">&#x27;charles&#x27;</span>,<span class="string">&#x27;martina&#x27;</span>,<span class="string">&#x27;michael&#x27;</span>,<span class="string">&#x27;florence&#x27;</span>,<span class="string">&#x27;eli&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(players[<span class="number">2</span>:])</span><br></pre></td></tr></table></figure><p>无论列表有多长，切片都可以让你输出从指定位置到列表末尾的所有记录，其中，负数索引表示返回离列表末尾相应距离的元素，例如，输出列表最后三个元素</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">players =[<span class="string">&#x27;charles&#x27;</span>,<span class="string">&#x27;martina&#x27;</span>,<span class="string">&#x27;michael&#x27;</span>,<span class="string">&#x27;florence&#x27;</span>,<span class="string">&#x27;eli&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(players[-<span class="number">3</span>:])</span><br></pre></td></tr></table></figure><h6 id="遍历切片"><a href="#遍历切片" class="headerlink" title="遍历切片"></a><strong>遍历切片</strong></h6><p>可在for循环中使用切片达到遍历切片的效果</p><p>例如，遍历列表前三名的队员：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">players =[<span class="string">&#x27;charles&#x27;</span>,<span class="string">&#x27;martina&#x27;</span>,<span class="string">&#x27;michael&#x27;</span>,<span class="string">&#x27;florence&#x27;</span>,<span class="string">&#x27;eli&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(“here are the first three players on my team:”)</span><br><span class="line"><span class="keyword">for</span> player <span class="keyword">in</span> players[:<span class="number">3</span>]</span><br><span class="line">    <span class="built_in">print</span>(player.title())</span><br></pre></td></tr></table></figure><p>在很多情况下，切片很有用。例如，在编写游戏时，可以在玩家退出游戏时将其最终得分加入到一个列表中，然后获取该玩家的三个最高分；在编写web应用程序的时候可以用来分页显示信息。</p><h6 id="复制列表"><a href="#复制列表" class="headerlink" title="复制列表"></a><strong>复制列表</strong></h6><p>要复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引（[：]）；让Python创建一个始于第一个元素，终于最后一个元素的切片，即复制整个列表。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">players =[<span class="string">&#x27;charles&#x27;</span>,<span class="string">&#x27;martina&#x27;</span>,<span class="string">&#x27;michael&#x27;</span>,<span class="string">&#x27;florence&#x27;</span>,<span class="string">&#x27;eli&#x27;</span>]</span><br><span class="line">player = players</span><br><span class="line"><span class="built_in">print</span>(player)</span><br></pre></td></tr></table></figure><p>注意：这种方法复制出的是两个列表，可分别向两个列表中插入不同的数据。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lowbit函数原理</title>
      <link href="/2021/01/24/lowbit%E5%87%BD%E6%95%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2021/01/24/lowbit%E5%87%BD%E6%95%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>lowbit()函数所求的是最低位1的位置</p><p>也可以通过位运算来计算 ：</p><p>int Lowbit(x) {</p><p> return x&amp;(-x);</p><p>}</p><p>例如：</p><p><strong>1&gt; x &#x3D; 1:</strong></p><p>十进制转二进制（设位数为８）：</p><p>1 &#x3D;&gt; 0000 0001</p><p>-1&#x3D;&gt; 1111 1111**(此处为1的补码)**</p><p>1&amp;(-1)的二进制位运算为(同1异0)：</p><p><img src="/img/post/lowbit%E5%87%BD%E6%95%B0%E5%8E%9F%E7%90%86/1&(-1).png" alt="1&amp;(-1)" title="1&amp;(-1)"></p><p>所以1&amp;(-1)&#x3D;1</p><p><strong>2&gt; x &#x3D; 6:</strong></p><p>十进制转二进制（设位数为８）：</p><p>6 &#x3D;&gt; 0000 0110</p><p>-6&#x3D;&gt; 1111 1010**(此处为6的补码)**</p><p>6&amp;(-6)的二进制位运算为(同1异0)：</p><p><img src="/img/post/lowbit%E5%87%BD%E6%95%B0%E5%8E%9F%E7%90%86/6&(-6).png" alt="6&amp;(-6)" title="6&amp;(-6)"></p><p>所以6&amp;(-6)&#x3D;2</p><p><strong>总结：</strong></p><p>求出2^p(其中p: x 的二进制表示数中， 右向左数第一个1的位置)，</p><p>如6的二进制表示为110，向左数第零个为0，第一个为1，则p&#x3D;1，</p><p>故Lowbit(6) &#x3D; 2^1 &#x3D; 2。</p><p><strong>或直接理解为：二进制按位与运算，返回不大于x的2的最大次方因子</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 函数实现 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单了解STL</title>
      <link href="/2021/01/19/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3STL/"/>
      <url>/2021/01/19/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3STL/</url>
      
        <content type="html"><![CDATA[<h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>STL 是“Standard Template Library”的缩写，中文译为“标准模板库”或者“泛型库”。STL 是 C++ 标准库的一部分，不用单独安装。</p><p>在实际的开发过程中，数据结构本身的重要性不会逊于操作于数据结构的算法的重要性，当程序中存在着对时间要求很高的部分时，数据结构的选择就显得更加重要。经典的数据结构数量有限，但是我们常常重复着一些为了实现向量、链表等结构而编写的代码，这些代码都十分相似，只是为了适应不同数据的变化而在细节上有所出入。</p><p>C++ 对模板（Template）支持得很好，STL 就是借助模板把常用的数据结构及其算法都实现了一遍，并且做到了数据结构和算法的分离。例如，vector 的底层为顺序表（数组），list 的底层为双向链表，deque 的底层为循环队列，set 的底层为红黑树，hash_set 的底层为哈希表。</p><h5 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h5><p> HP STL是C++ STL的第一个实现版本，而且开放源代码。其他版本的C++ STL，一般是以HP STL为蓝本实现出来的。不过，现在已经很少直接使用此版本的 STL 了。SGI STL 在 Linux 平台上的性能非常出色。PJ STL 被 Visual C++ 编译器所采用，但和 HP STL、SGI STL 不同的是，PJ STL 并不是开源。</p><h5 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a><strong>组成部分</strong></h5><p>STL可分为容器(containers)、迭代器(iterators)、空间配置器(allocator)、配接器(adapters)、算法(algorithms)、仿函数(functors)六个部分。</p><table><thead><tr><th>STL的组成</th><th align="center">含义</th></tr></thead><tbody><tr><td>容器</td><td align="center">一些封装<a href="http://c.biancheng.net/data_structure/">数据结构</a>的模板类，例如 vector 向量容器、list 列表容器等。</td></tr><tr><td>算法</td><td align="center">STL 提供了非常多（大约 100 个）的数据结构算法，它们都被设计成一个个的模板函数，这些算法在 std 命名空间中定义，其中大部分算法都包含在头文件 <algorithm> 中，少部分位于头文件 <numeric> 中。</td></tr><tr><td>迭代器</td><td align="center">在 <a href="http://c.biancheng.net/cplus/">C++</a> STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂。</td></tr><tr><td>函数对象</td><td align="center">如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。</td></tr><tr><td>适配器</td><td align="center">可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。</td></tr><tr><td>内存分配器</td><td align="center">为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。</td></tr></tbody></table><p>在C++标准中，STL被组织为下面的13个头文件：<a href="https://baike.baidu.com/item/algorithm">algorithm</a>、<a href="https://baike.baidu.com/item/deque">deque</a>、<a href="https://baike.baidu.com/item/functional">functional</a>、<a href="https://baike.baidu.com/item/iterator">iterator</a>、<a href="https://baike.baidu.com/item/vector">vector</a>、<a href="https://baike.baidu.com/item/list">list</a>、<a href="https://baike.baidu.com/item/map/5808503">map</a>、memory、<a href="https://baike.baidu.com/item/numeric">numeric</a>、<a href="https://baike.baidu.com/item/queue">queue</a>、<a href="https://baike.baidu.com/item/set">set</a>、<a href="https://baike.baidu.com/item/stack">stack</a>和<a href="https://baike.baidu.com/item/utility">utility</a>。</p><h5 id="一些常用头文件"><a href="#一些常用头文件" class="headerlink" title="一些常用头文件"></a>一些常用头文件</h5><h6 id="include"><a href="#include" class="headerlink" title="#include "></a>#include <vector></h6><p>vector是变长数组，支持随机访问，不支持在任意位置O(1)插入。为了保证效率，元素的增删一般应该在末尾进行。</p><p>​    声明</p><p>​       #include <vector>    头文件</p><p>​       vector<int> a;       相当于一个长度动态变化的int数组</p><p>​       vector<int> b[233];  相当于第一维长233，第二位长度动态变化的int数组</p><p>​       struct rec{…};</p><p>​       vector<rec> c;       自定义的结构体类型也可以保存在vector中</p><p>​    size&#x2F;empty</p><p>size函数返回vector的实际长度（包含的元素个数），empty函数返回一个bool类型，表明vector是否为空。二者的时间复杂度都是O(1)。</p><p>所有的STL容器都支持这两个方法，含义也相同，之后我们就不再重复给出。</p><p>​    clear</p><p>​       clear函数把vector清空。</p><p>​    迭代器</p><p>​       迭代器就像STL容器的“指针”，可以用星号“*”操作符解除引用。</p><p>​       一个保存int的vector的迭代器声明方法为：</p><p>​       vector<int>::iterator it;</p><p>vector的迭代器是“随机访问迭代器”，可以把vector的迭代器与一个整数相加减，其行为和指针的移动类似。可以把vector的两个迭代器相减，其结果也和指针相减类似，得到两个迭代器对应下标之间的距离。</p><p>​    begin&#x2F;end</p><p>begin函数返回指向vector中第一个元素的迭代器。例如a是一个非空的vector，则*a.begin()与a[0]的作用相同。</p><p>所有的容器都可以视作一个“前闭后开”的结构，end函数返回vector的尾部，即第n个元素再往后的“边界”。*a.end()与a[n]都是越界访问，其中n&#x3D;a.size()。</p><p>下面两份代码都遍历了vector<int>a，并输出它的所有元素。</p><p>for (int I &#x3D; 0; I &lt; a.size(); I ++) cout &lt;&lt; a[i] &lt;&lt; endl;</p><p>for (vector<int>::iterator it &#x3D; a.begin(); it !&#x3D; a.end(); it ++) cout &lt;&lt; *it &lt;&lt; endl;</p><p>​    front&#x2F;back</p><p>​       front函数返回vector的第一个元素，等价于*a.begin() 和 a[0]。</p><p>​       back函数返回vector的最后一个元素，等价于*&#x3D;&#x3D;a.end() 和 a[a.size() – 1]。</p><p>​    push_back() 和 pop_back()</p><p>a.push_back(x) 把元素x插入到vector a的尾部。</p><p>​       b.pop_back() 删除vector a的最后一个元素。</p><h6 id="include-1"><a href="#include-1" class="headerlink" title="#include "></a>#include <queue></h6><p>头文件queue主要包括循环队列queue和优先队列priority_queue两个容器。</p><p>​    </p><p>​    声明</p><p>​       queue<int> q;</p><p>​       struct rec{…}; queue<rec> q;    &#x2F;&#x2F;结构体rec中必须定义小于号</p><p>​       priority_queue<int> q;    &#x2F;&#x2F; 大根堆</p><p>​      priority_queue&lt;int, vector<int>, greater<int> q;  &#x2F;&#x2F; 小根堆</p><p>​       priority_queue&lt;pair&lt;int, int&gt;&gt;q;</p><p>​    循环队列 queue</p><p>​       push 从队尾插入</p><p>​       pop 从队头弹出</p><p>​       front 返回队头元素</p><p>​       back 返回队尾元素</p><p>​    优先队列 priority_queue</p><p>​       push 把元素插入堆</p><p>​       pop 删除堆顶元素</p><p>​       top 查询堆顶元素（最大值）</p><h6 id="include-2"><a href="#include-2" class="headerlink" title="#include "></a>#include <stack></h6><p>头文件stack包含栈。声明和前面的容器类似。</p><p>push 向栈顶插入</p><p>pop 弹出栈顶元素</p><h6 id="include-3"><a href="#include-3" class="headerlink" title="#include "></a>#include <deque></h6><p>双端队列deque是一个支持在两端高效插入或删除元素的连续线性存储空间。它就像是vector和queue的结合。与vector相比，deque在头部增删元素仅需要O(1)的时间；与queue相比，deque像数组一样支持随机访问。</p><p>[] 随机访问</p><p>begin&#x2F;end，返回deque的头&#x2F;尾迭代器</p><p>front&#x2F;back 队头&#x2F;队尾元素</p><p>push_back 从队尾入队</p><p>push_front 从队头入队</p><p>pop_back 从队尾出队</p><p>pop_front 从队头出队</p><p>clear 清空队列</p><h6 id="include-4"><a href="#include-4" class="headerlink" title="#include "></a>#include <set></h6><p>头文件set主要包括set和multiset两个容器，分别是“有序集合”和“有序多重集合”，即前者的元素不能重复，而后者可以包含若干个相等的元素。set和multiset的内部实现是一棵红黑树，它们支持的函数基本相同。</p><p>声明</p><p>​    set<int> s;</p><p>struct rec{…}; set<rec> s;   &#x2F;&#x2F; 结构体rec中必须定义小于号</p><p>multiset<double> s;</p><p>size&#x2F;empty&#x2F;clear</p><p>​    与vector类似</p><p>迭代器</p><p>set和multiset的迭代器称为“双向访问迭代器”，不支持“随机访问”，支持星号(*)解除引用，仅支持”++”和–“两个与算术相关的操作。</p><p>设it是一个迭代器，例如set<int>::iterator it;</p><p>若把it++，则it会指向“下一个”元素。这里的“下一个”元素是指在元素从小到大排序的结果中，排在it下一名的元素。同理，若把it–，则it将会指向排在“上一个”的元素。</p><p>​    begin&#x2F;end</p><p>​       返回集合的首、尾迭代器，时间复杂度均为O(1)。</p><p>​       s.begin() 是指向集合中最小元素的迭代器。</p><p>s.end() 是指向集合中最大元素的下一个位置的迭代器。换言之，就像vector一样，是一个“前闭后开”的形式。因此–s.end()是指向集合中最大元素的迭代器。</p><p>​    insert</p><p>​       s.insert(x)把一个元素x插入到集合s中，时间复杂度为O(logn)。</p><p>​       在set中，若元素已存在，则不会重复插入该元素，对集合的状态无影响。</p><p>​    find</p><p>s.find(x) 在集合s中查找等于x的元素，并返回指向该元素的迭代器。若不存在，则返回s.end()。时间复杂度为O(logn)。</p><p>​    lower_bound&#x2F;upper_bound</p><p>​       这两个函数的用法与find类似，但查找的条件略有不同，时间复杂度为 O(logn)。</p><p>s.lower_bound(x) 查找大于等于x的元素中最小的一个，并返回指向该元素的迭代器。</p><p>s.upper_bound(x) 查找大于x的元素中最小的一个，并返回指向该元素的迭代器。</p><p>​    erase</p><p>设it是一个迭代器，s.erase(it) 从s中删除迭代器it指向的元素，时间复杂度为O(logn)</p><p>设x是一个元素，s.erase(x) 从s中删除所有等于x的元素，时间复杂度为O(k+logn)，其中k是被删除的元素个数。</p><p>​    count</p><p>​       s.count(x) 返回集合s中等于x的元素个数，时间复杂度为 O(k +logn)，其中k为元素x的个数。</p><h6 id="include-5"><a href="#include-5" class="headerlink" title="#include "></a>#include <map></h6><p>map容器是一个键值对key-value的映射，其内部实现是一棵以key为关键码的红黑树。Map的key和value可以是任意类型，其中key必须定义小于号运算符。</p><p>​    声明</p><p>​       map&lt;key_type, value_type&gt; name;</p><p>​       例如：</p><p>​       map&lt;long, long, bool&gt; vis;</p><p>​       map&lt;string, int&gt; hash;</p><p>​       map&lt;pair&lt;int, int&gt;, vector<int>&gt; test;</p><p>​    size&#x2F;empty&#x2F;clear&#x2F;begin&#x2F;end均与set类似。</p><p>​    Insert&#x2F;erase</p><p>​       与set类似，但其参数均是pair&lt;key_type, value_type&gt;。</p><p>​    find</p><p>​       h.find(x) 在变量名为h的map中查找key为x的二元组。</p><p>​    []操作符</p><p>​       h[key] 返回key映射的value的引用，时间复杂度为O(logn)。</p><p>[]操作符是map最吸引人的地方。我们可以很方便地通过h[key]来得到key对应的value，还可以对h[key]进行赋值操作，改变key对应的value。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> STL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵连乘</title>
      <link href="/2020/12/13/%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98/"/>
      <url>/2020/12/13/%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98/</url>
      
        <content type="html"><![CDATA[<h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>实现矩阵连乘算法。输入n个矩阵的维度（n+1个数, n&gt;2），输出矩阵连乘的最小数乘次数以及连乘次序，即矩阵加括号的方式，如: (A1((A2A3)A4))。</p><p>提交格式：<br>实现void solve(int n,int p[],int out[])函数。</p><p>参数n为矩阵个数，p为关于矩阵维数的n+1个数，矩阵Ai的维数为(p[i-1],p[i]),out[0]为最小数乘次数MOD1000000007，out[i]为输出的连乘次序(i&gt;0)。2&lt;n&lt;&#x3D;500,2&lt;p[i]&lt;&#x3D;500。</p><p>输出连乘次序时，请将(替换为-1、)替换为-2，矩阵Ai替换为i,输出到out数组中。<br>请不要printf输出任何内容。</p><p>输入样例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">n</span>=<span class="number">5</span>,p=&#123;<span class="number">10</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>输出样例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">out</span>=&#123;<span class="number">292</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,-<span class="number">2</span>,<span class="number">5</span>,-<span class="number">2</span>,-<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><h5 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a><strong>核心思路</strong></h5><ol><li>最优子结构分析，建立递归关系，得到递归表达式；</li><li>依据其递归式以自底向上的方式进行迭代，得到m矩阵和s矩阵；</li><li>通过s矩阵加括号；</li><li>构造主函数进行调试。</li></ol><h5 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a><strong>实现要点</strong></h5><ol><li>关键在于构造递推表达式，这也是动态规划的难点所在；</li><li>由于数据可能比较大，数据类型选择long long;</li><li>虽然题目是加数字，但和加括号一样，借助通过递归实现。</li></ol><h5 id="code"><a href="#code" class="headerlink" title="code"></a>code</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> m[<span class="number">500</span>][<span class="number">500</span>], s[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> number;</span><br><span class="line"><span class="type">void</span> <span class="title function_">traceback</span><span class="params">(<span class="type">long</span> <span class="type">long</span> i, <span class="type">long</span> <span class="type">long</span> j, <span class="type">int</span>* out)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> p[], <span class="type">int</span> out[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>; i &lt;= n; i++) m[i][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> r = <span class="number">1</span>; r &lt;= n - <span class="number">1</span>; r++)  <span class="comment">//r是i和j的间隔宽度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>; i &lt;= n - r; i++) <span class="comment">//随着间隔宽度r的增长，i递减，直到i为1</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="type">long</span> <span class="type">long</span> j = i + r;</span><br><span class="line">m[i][j] = m[i + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[i] * p[j]; <span class="comment">// 在i的位置断链,分解为m[i][i]和m[i+1][j]。</span></span><br><span class="line">s[i][j] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> k = i + <span class="number">1</span>; k &lt; j; k++) <span class="comment">// 计算最小的m[i][j]</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="type">long</span> <span class="type">long</span> t = m[i][k] + m[k + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[k] * p[j];</span><br><span class="line"><span class="keyword">if</span> (t &lt; m[i][j]) </span><br><span class="line">&#123;</span><br><span class="line">m[i][j] = t;</span><br><span class="line">s[i][j] = k;</span><br><span class="line">&#125; <span class="comment">//k是i和j之间的最佳断链位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">out[<span class="number">0</span>] = m[<span class="number">1</span>][n]% <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">out[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">number = n;</span><br><span class="line">traceback(<span class="number">1</span>,n,out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">traceback</span><span class="params">(<span class="type">long</span> <span class="type">long</span> i, <span class="type">long</span> <span class="type">long</span> j, <span class="type">int</span>* out)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> k;</span><br><span class="line"><span class="keyword">if</span> (i == j) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (k = number; out[k + <span class="number">1</span>] != i; k--)</span><br><span class="line">&#123;</span><br><span class="line">out[k + <span class="number">1</span>] = out[k];</span><br><span class="line">&#125;</span><br><span class="line">out[k+<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">number++;</span><br><span class="line"><span class="keyword">for</span> (k = number; out[k] != j; k--)</span><br><span class="line">&#123;</span><br><span class="line">out[k + <span class="number">1</span>] = out[k];</span><br><span class="line">&#125;</span><br><span class="line">out[k + <span class="number">1</span>] = <span class="number">-2</span>;</span><br><span class="line">number++;</span><br><span class="line">traceback(i, s[i][j], out);</span><br><span class="line">traceback(s[i][j] + <span class="number">1</span>, j, out);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n=<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> p[<span class="number">6</span>] = &#123; <span class="number">10</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">int</span> out[<span class="number">1500</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">solve(n, p, out);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;out=&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= number; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, out[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的深度优先遍历</title>
      <link href="/2020/11/28/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/"/>
      <url>/2020/11/28/%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>分别用邻接矩阵和邻接链表两种数据结构实现图的深度优先遍历算法，输出遍历的结点序列，并分析算法的时间复杂度。 </p><p>提交格式： </p><p>邻接矩阵数据结构实现void solveA(int n, int m, int e[][2], int out[])函数。 </p><p>邻接链表数据结构实现void solveB(int n, int m, int e[][2], int out[])函数。 </p><p>参数n为结点个数，m为边条数，e为所有边，out为输出序列。1&lt;&#x3D;n&lt;&#x3D;3000,1&lt;&#x3D;m&lt;&#x3D;100000,0&lt;&#x3D;e[i][j]&lt;n。 </p><p>遍历的起始结点为0，邻接矩阵数据结构中按行从左到右遍历邻居结点，邻接链表数据结构中按存储顺序遍历邻居结点，图为无向图。 </p><p>请不要printf输出任何内容。 </p><p>输入样例： </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">n</span>=<span class="number">5</span>,m=<span class="number">10</span>,e=&#123;&#123;<span class="number">2</span>,<span class="number">4</span>&#125;,&#123;<span class="number">3</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">1</span>&#125;,&#123;<span class="number">4</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">0</span>,<span class="number">4</span>&#125;&#125; </span><br></pre></td></tr></table></figure><p>输出样例： </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">solveA</span>：out=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125; </span><br><span class="line"><span class="attribute">solveB</span>：out=&#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><h5 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a><strong>核心思路</strong></h5><ol><li>每种solve里都需调用相应的create和dfs;</li><li>实现相应的create和dfs；</li><li>构造主函数进行调试。</li></ol><h5 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a><strong>实现要点</strong></h5><ol><li>动态分配内存创建数组；</li><li>函数间参数的传递；</li><li>visited[]的初始化；</li><li>非连通图的考虑；</li><li>邻接表深度遍历时的回退。</li></ol><h5 id="code"><a href="#code" class="headerlink" title="code"></a>code</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i, j,k,s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span>** arc;   <span class="comment">//邻接矩阵 可看作边表   </span></span><br><span class="line"><span class="type">int</span> numVertexes, numEdges;</span><br><span class="line">&#125;MGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图的邻接链表存储结构</span></span><br><span class="line"><span class="comment">//边表节点结构，一个adjvex用来存储邻接点的位置，一个next指针用来指向下一个节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> adjvex;  <span class="comment">//存储顶点下标信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点表节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> Vexs;  <span class="comment">//用来存储顶点信息</span></span><br><span class="line">EdgeNode* firstedge;  <span class="comment">//用来存储当前顶点的下一个顶点</span></span><br><span class="line">&#125; VexList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里用动态数组存储顶点表，然后numVertex,numEdge是一个图的顶点数和边数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">VexList* q;</span><br><span class="line"><span class="type">int</span> Vertexs, Edges;</span><br><span class="line">&#125; LGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数n为结点个数，m为边条数，e为所有边，out为输出序列。1 &lt;= n &lt;= 3000, 1 &lt;= m &lt;= 100000, 0 &lt;= e[i][j] &lt; n。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">solveA</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> e[][<span class="number">2</span>], <span class="type">int</span> out[])</span>;<span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create</span><span class="params">(MGraph* G, <span class="type">int</span> e[][<span class="number">2</span>])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(MGraph* G, <span class="type">int</span> i, <span class="type">int</span>* visited, <span class="type">int</span> outA[])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">solveB</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> e[][<span class="number">2</span>], <span class="type">int</span> out[])</span>;<span class="comment">//邻接链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcreate</span><span class="params">(LGraph* G, <span class="type">int</span> e[][<span class="number">2</span>])</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LDFS</span><span class="params">(LGraph* G, <span class="type">int</span> i, <span class="type">int</span>* visited, <span class="type">int</span> outB[])</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> N = <span class="number">0</span>, M = <span class="number">0</span>;</span><br><span class="line">printf_s(<span class="string">&quot;请输入顶点数:\n&quot;</span>);</span><br><span class="line">scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">printf_s(<span class="string">&quot;请输入连边数:\n&quot;</span>);</span><br><span class="line">scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;M);</span><br><span class="line"><span class="keyword">if</span> (N &lt; <span class="number">1</span> || N &gt; <span class="number">3000</span> || M &lt; <span class="number">1</span> || M &gt; <span class="number">100000</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>(*E)[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br><span class="line">E = (<span class="type">int</span>(*)[<span class="number">2</span>])<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * M * <span class="number">2</span>);</span><br><span class="line"><span class="type">int</span>* OUT = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * N);</span><br><span class="line"><span class="keyword">if</span> (E == <span class="literal">NULL</span> ||OUT==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line">printf_s(<span class="string">&quot;请输入所有连边:\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;E[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">solveA(N, M, E, OUT);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, OUT[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">solveB(N, M, E, OUT);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, OUT[i]);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">solveA</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> e[][<span class="number">2</span>], <span class="type">int</span> out[])</span></span><br><span class="line">&#123;</span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line">MGraph* G = (MGraph*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MGraph));</span><br><span class="line">G-&gt;numVertexes = n;</span><br><span class="line">G-&gt;numEdges = m;</span><br><span class="line">create(G, e);</span><br><span class="line"><span class="type">int</span>* visited;</span><br><span class="line">visited = (<span class="type">int</span>*)<span class="built_in">calloc</span>(G-&gt;numVertexes, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;numVertexes; i++)</span><br><span class="line"><span class="keyword">if</span> (visited[i] == <span class="number">0</span>)</span><br><span class="line">DFS(G, i, visited, out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create</span><span class="params">(MGraph* G, <span class="type">int</span> e[][<span class="number">2</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">G-&gt;arc = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*) * G-&gt;numVertexes);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;numVertexes; i++)</span><br><span class="line">&#123;</span><br><span class="line">G-&gt;arc[i] = (<span class="type">int</span>*)<span class="built_in">calloc</span>(G-&gt;numVertexes, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G-&gt;numEdges; j++)</span><br><span class="line">&#123;</span><br><span class="line">G-&gt;arc[e[j][<span class="number">0</span>]][e[j][<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">G-&gt;arc[e[j][<span class="number">1</span>]][e[j][<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(MGraph* G, <span class="type">int</span> i, <span class="type">int</span>* visited, <span class="type">int</span> outA[])</span></span><br><span class="line">&#123;</span><br><span class="line">outA[s++] = i;</span><br><span class="line">visited[i] = <span class="number">1</span>;   <span class="comment">//被访问的标记 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; G-&gt;numVertexes; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (G-&gt;arc[i][k] == <span class="number">1</span> &amp;&amp; visited[k] == <span class="number">0</span>)   <span class="comment">//边(i,j)存在且j顶点未被访问，递归 </span></span><br><span class="line">DFS(G, k, visited, outA);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">solveB</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> e[][<span class="number">2</span>], <span class="type">int</span> out[])</span></span><br><span class="line">&#123;</span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line">LGraph* G = (LGraph*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LGraph));</span><br><span class="line">G-&gt;Vertexs = n;</span><br><span class="line">G-&gt;Edges = m;</span><br><span class="line">Lcreate(G, e);</span><br><span class="line"><span class="type">int</span>* visited;</span><br><span class="line">visited = (<span class="type">int</span>*)<span class="built_in">calloc</span>(G-&gt;Vertexs, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;Vertexs; i++)</span><br><span class="line"><span class="keyword">if</span> (visited[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">k = <span class="number">1</span>;</span><br><span class="line">LDFS(G, i, visited, out);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcreate</span><span class="params">(LGraph* G, <span class="type">int</span> e[][<span class="number">2</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">G-&gt;q = (VexList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(VexList) * G-&gt;Vertexs);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;Vertexs; i++)</span><br><span class="line">&#123;</span><br><span class="line">G-&gt;q[i].Vexs = i;</span><br><span class="line">G-&gt;q[i].firstedge = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; G-&gt;Edges; j++)</span><br><span class="line">&#123;</span><br><span class="line">EdgeNode* node1 = (EdgeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));</span><br><span class="line">node1-&gt;adjvex = e[j][<span class="number">1</span>];</span><br><span class="line">node1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (G-&gt;q[e[j][<span class="number">0</span>]].firstedge == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">G-&gt;q[e[j][<span class="number">0</span>]].firstedge = node1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">EdgeNode* w = G-&gt;q[e[j][<span class="number">0</span>]].firstedge;</span><br><span class="line"><span class="keyword">while</span> (w-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">w = w-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">w-&gt;next = node1;</span><br><span class="line">&#125;</span><br><span class="line">EdgeNode* node2 = (EdgeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));</span><br><span class="line">node2-&gt;adjvex = e[j][<span class="number">0</span>];</span><br><span class="line">node2-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (G-&gt;q[e[j][<span class="number">1</span>]].firstedge == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">G-&gt;q[e[j][<span class="number">1</span>]].firstedge = node2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">EdgeNode* w = G-&gt;q[e[j][<span class="number">1</span>]].firstedge;</span><br><span class="line"><span class="keyword">while</span> (w-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">w = w-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">w-&gt;next = node2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">LDFS</span><span class="params">(LGraph* G, <span class="type">int</span> i, <span class="type">int</span>* visited, <span class="type">int</span> outB[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (k==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">j = s;</span><br><span class="line">outB[s++] = i;</span><br><span class="line">    visited[i] = <span class="number">1</span>;   <span class="comment">//被访问的标记 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (G-&gt;q[i].firstedge != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">EdgeNode* t = (G-&gt;q[i].firstedge);</span><br><span class="line"><span class="keyword">while</span> (visited[t-&gt;adjvex] == <span class="number">1</span> &amp;&amp; t-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = t-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (visited[t-&gt;adjvex] == <span class="number">1</span> &amp;&amp; t-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line">j--;</span><br><span class="line">LDFS(G, outB[j], visited, outB);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">k = <span class="number">1</span>;</span><br><span class="line">LDFS(G, t-&gt;adjvex, visited, outB);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DJmini</title>
      <link href="/2020/11/20/DJmini/"/>
      <url>/2020/11/20/DJmini/</url>
      
        <content type="html"><![CDATA[<h2 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h2><p>项目地址：<a href="https://github.com/sleepyfox-github/DJmini.git">https://github.com/sleepyfox-github/DJmini.git</a></p><p>音乐游戏，大二C++结课作业，依赖于acllib库实现，仅支持Windows环境下运行。</p><p>DJmini是一款音乐游戏，提供了流畅的节奏游戏体验，目前仅包含一个曲目及相应的音乐背景。创作灵感来源于室友最近在玩的一款音乐游戏— <a href="https://store.steampowered.com/app/960170/DJMAX_RESPECT_V/">DJMAX RESPECT V</a>，游戏名“DJmini”正是为了致敬该游戏，而“mini”意在表明这只是一个卑微学习者的练手项目，十分简陋😅</p><h2 id="软件说明"><a href="#软件说明" class="headerlink" title="软件说明"></a>软件说明</h2><h3 id="游戏使用说明"><a href="#游戏使用说明" class="headerlink" title="游戏使用说明"></a>游戏使用说明</h3><h4 id="下载及运行"><a href="#下载及运行" class="headerlink" title="下载及运行"></a>下载及运行</h4><ol><li><p><a href="https://gitee.com/wanli-0ziyuan/DJmini-release">下载压缩包：</a></p><p><img src="/img/post/DJmini/%E4%B8%8B%E8%BD%BD%E5%8E%8B%E7%BC%A9%E5%8C%85.png" alt="下载压缩包" title="下载压缩包"></p></li><li><p>下载完成并解压后，双击DJmini文件夹中的“DJmini.exe”文件运行游戏：</p><p><img src="/img/post/DJmini/%E8%A7%A3%E5%8E%8B.png" alt="解压" title="解压"></p><p><img src="/img/post/DJmini/%E8%BF%90%E8%A1%8C%E6%B8%B8%E6%88%8F.png" alt="运行游戏" title="运行游戏"></p></li></ol><h4 id="玩法说明"><a href="#玩法说明" class="headerlink" title="玩法说明"></a>玩法说明</h4><h5 id="音轨"><a href="#音轨" class="headerlink" title="音轨"></a>音轨</h5><p>即下落轨道数，共四个。对应键位有左手区和右手区之分，字母键均为大写，故需将键盘大写锁定：</p><p>左手区：A﹑S﹑D﹑F</p><p>右手区：J﹑K﹑L﹑; </p><h5 id="音符（Note）"><a href="#音符（Note）" class="headerlink" title="音符（Note）"></a>音符（Note）</h5><p>有样式之分，蓝色音符的音轨对应左手区键位，粉色音符的音轨对应右手区键位。击中时附有音效，随即消失。</p><p><img src="/img/post/DJmini/%E9%9F%B3%E7%AC%A6.png" alt="音符" title="音符"></p><h5 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h5><ol><li>敲击音符所在音轨对应键位击打。蓝色音符的音轨对应左手区键位，粉色音符的音轨对应右手区键位。</li><li>音符刚到达判定线，到其完全从窗口底部消失的这段时间，击打相应键位，视为击中。其他时刻（如音符还未到达判定线﹑音符已消失等）击打，视为击打无效。</li></ol><h5 id="计分与评级"><a href="#计分与评级" class="headerlink" title="计分与评级"></a>计分与评级</h5><h6 id="计分"><a href="#计分" class="headerlink" title="计分"></a>计分</h6><p>不显示具体得分，只实时显示命中率🙃。</p><p>命中率&#x3D;击中音符数&#x2F;已生成音符数*100%</p><h6 id="评级"><a href="#评级" class="headerlink" title="评级"></a>评级</h6><table><thead><tr><th align="center">命中率</th><th align="center">小于60%</th><th align="center">60%~70%</th><th align="center">70%~80%</th><th align="center">80%~90%</th><th align="center">90%~100%</th></tr></thead><tbody><tr><td align="center">评级</td><td align="center">Cheer up!</td><td align="center">Not bad!</td><td align="center">Nice job!</td><td align="center">Excellent!</td><td align="center">Perfect!</td></tr></tbody></table><h5 id="完整过程"><a href="#完整过程" class="headerlink" title="完整过程"></a>完整过程</h5><ol><li><p>5秒倒计时，倒计时结束，游戏开始；</p><p><img src="/img/post/DJmini/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%A7%8B.png" alt="游戏开始" title="游戏开始"></p></li><li><p>音符下落，玩家按键击打。同时游戏区右上角实时显示命中率和游戏进度；</p></li><li><p>游戏进度到达100%，游戏结束。片刻后在动画播放区显示评级。</p><p><img src="/img/post/DJmini/%E6%B8%B8%E6%88%8F%E7%BB%93%E6%9D%9F.png" alt="游戏结束" title="游戏结束"></p></li></ol><h3 id="源码编译说明"><a href="#源码编译说明" class="headerlink" title="源码编译说明"></a>源码编译说明</h3><h4 id="示例环境"><a href="#示例环境" class="headerlink" title="示例环境"></a>示例环境</h4><p>Windows10家庭版中文版，系统类型为64位，选用Visual Studio 2019 Community 作为开发环境。</p><h4 id="所需文件下载"><a href="#所需文件下载" class="headerlink" title="所需文件下载"></a>所需文件下载</h4><p><a href="https://gitee.com/wanli-0ziyuan/DJmini-resourse">下载压缩包</a></p><p><img src="/img/post/DJmini/%E4%B8%8B%E8%BD%BD%E6%BA%90%E6%96%87%E4%BB%B6.png" alt="下载源文件" title="下载源文件"></p><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><h5 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h5><p>打开Visual Studio 2019，点击创建新项目。</p><p><img src="/img/post/DJmini/%E5%88%9B%E5%BB%BA%E6%96%B0%E9%A1%B9%E7%9B%AE.png" alt="创建新项目" title="创建新项目"></p><h5 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h5><p>选择windows桌面向导，然后选择下一步。</p><p><img src="/img/post/DJmini/%E9%80%89%E6%8B%A9windows%E6%A1%8C%E9%9D%A2%E5%90%91%E5%AF%BC.png" alt="选择windows桌面向导" title="选择windows桌面向导"></p><h5 id="Step3"><a href="#Step3" class="headerlink" title="Step3"></a>Step3</h5><p>填写名称，选择项目创建位置。</p><p><img src="/img/post/DJmini/%E9%80%89%E6%8B%A9%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA%E4%BD%8D%E7%BD%AE.png" alt="选择项目创建位置" title="选择项目创建位置"></p><h5 id="Step4"><a href="#Step4" class="headerlink" title="Step4"></a>Step4</h5><h6 id="应用程序类型"><a href="#应用程序类型" class="headerlink" title="应用程序类型"></a>应用程序类型</h6><p>桌面应用程序（.exe）</p><p><img src="/img/post/DJmini/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%9E%8B.png" alt="应用程序类型" title="应用程序类型"></p><h6 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h6><p>空项目，然后创建。</p><p><img src="/img/post/DJmini/%E5%85%B6%E4%BB%96%E9%80%89%E9%A1%B9.png" alt="其他选项" title="其他选项"></p><h4 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h4><h5 id="Step1-1"><a href="#Step1-1" class="headerlink" title="Step1"></a>Step1</h5><p>根据创建项目的位置找到项目文件夹</p><p><img src="/img/post/DJmini/%E6%89%BE%E5%88%B0%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt="找到项目文件夹" title="找到项目文件夹"></p><h5 id="Step2-1"><a href="#Step2-1" class="headerlink" title="Step2"></a>Step2</h5><p>将下载的压缩包解压，然后把.cpp文件,.h文件和资源文件三个文件夹下的所有文件拷贝到刚才的项目文件夹中。</p><p><img src="/img/post/DJmini/%E6%8B%B7%E8%B4%9D1.png" alt="拷贝1" title="拷贝1"></p><p><img src="/img/post/DJmini/%E6%8B%B7%E8%B4%9D2.png" alt="拷贝2" title="拷贝2"></p><p><img src="/img/post/DJmini/%E6%8B%B7%E8%B4%9D3.png" alt="拷贝3" title="拷贝3"></p><h4 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h4><h5 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h5><p>右键单击头文件，选择“添加”-&gt;“现有项”</p><p><img src="/img/post/DJmini/%E6%B7%BB%E5%8A%A0%E7%8E%B0%E6%9C%89%E9%A1%B9.png" alt="添加现有项" title="添加现有项"></p><p>选中项目文件夹下所有的.h文件，然后点击添加。</p><p><img src="/img/post/DJmini/%E9%80%89%E4%B8%AD%E5%A4%B4%E6%96%87%E4%BB%B6.png" alt="选中头文件" title="选中头文件"></p><h5 id="源文件和资源文件"><a href="#源文件和资源文件" class="headerlink" title="源文件和资源文件"></a>源文件和资源文件</h5><p>添加步骤同头文件，源文件为所有的.cpp文件，资源文件为所有Jpg文件以及两个wav文件，一个Mp3文件。</p><h4 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h4><p>1.<em>项目 -&gt;</em> <em>配置属性</em><em>-&gt;C&#x2F;C++-&gt;<strong>代码生成</strong>-&gt;<strong>运行库* <em>:选择</em> *多线程调试（</strong>&#x2F;MT**）。</em></p><p><img src="/img/post/DJmini/%E8%BF%90%E8%A1%8C%E5%BA%931.jpg" alt="运行库1" title="运行库1"></p><p><img src="/img/post/DJmini/%E8%BF%90%E8%A1%8C%E5%BA%932.png" alt="运行库2" title="运行库2"></p><p>2.<em>编译时，在下拉框中选择的是<strong>Release</strong>，</em>X86，然后生成解决方案。</p><p><img src="/img/post/DJmini/%E7%BC%96%E8%AF%91%E8%AE%BE%E7%BD%AE1.png" alt="编译设置1" title="编译设置1"></p><p><img src="/img/post/DJmini/%E7%BC%96%E8%AF%91%E8%AE%BE%E7%BD%AE2.jpg" alt="编译设置2" title="编译设置2"></p><p>3.在项目文件夹下找到“Release”文件夹，进入。</p><p><img src="/img/post/DJmini/Release%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt="Release文件夹" title="Release文件夹"></p><p>4.在“Release”文件夹下找到生成的.exe文件，拷贝到最初下载解压得到的文件夹中的“资源文件”下，双击.exe文件即可运行游戏。“资源文件”文件夹即为最终游戏包，可压缩打包发送给他人游玩。</p><p><img src="/img/post/DJmini/exe%E6%96%87%E4%BB%B6.png" alt="exe文件" title="exe文件"></p><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="Note类"><a href="#Note类" class="headerlink" title="Note类"></a>Note类</h3><h4 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h4><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><h6 id="公有"><a href="#公有" class="headerlink" title="公有"></a>公有</h6><p>音符左上角、右下角坐标：int nTopRect&#x3D;0,nBottomRect&#x3D;25;int nLeftRect, nRightRect;</p><p>音符样式(颜色)：int style;</p><h6 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h6><p>音符为圆角矩形，圆角部分的宽、高：int nWidth&#x3D;10, nHeight&#x3D;10;</p><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><h6 id="公有-1"><a href="#公有-1" class="headerlink" title="公有"></a>公有</h6><p>初始化音符信息</p><p>音符下落</p><p>绘制音符</p><h3 id="Area类"><a href="#Area类" class="headerlink" title="Area类"></a>Area类</h3><h4 id="成员-1"><a href="#成员-1" class="headerlink" title="成员"></a>成员</h4><h5 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h5><h6 id="保护-1"><a href="#保护-1" class="headerlink" title="保护"></a>保护</h6><p>区域左上角坐标：int x, y;</p><p>区域宽高：int width, height;</p><p>背景图片：ACL_Image img;</p><h5 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h5><h6 id="公有-2"><a href="#公有-2" class="headerlink" title="公有"></a>公有</h6><p>构造函数<br>拷贝构造函数<br>析构函数<br>区域绘制函数，声明为纯虚函数。</p><h3 id="GifArea类"><a href="#GifArea类" class="headerlink" title="GifArea类"></a>GifArea类</h3><h4 id="成员-2"><a href="#成员-2" class="headerlink" title="成员"></a>成员</h4><h5 id="变量-2"><a href="#变量-2" class="headerlink" title="变量"></a>变量</h5><h6 id="保护-2"><a href="#保护-2" class="headerlink" title="保护"></a>保护</h6><p>GIF数量：int gifnum;<br>帧数数组：int* zhen&#x3D;new int(gifnum + 1);<br>GifArea的编号：int id;<br>Gif相应的图片名：char imgname[14] &#x3D; “00-01-000.jpg”;<br>gif图片名序列：int v2 &#x3D; 0, v1 &#x3D; 1, w3 &#x3D; 0, w2 &#x3D; 0, w1 &#x3D; 0;</p><p>GifArea的编号和gif图片名序列用于加载图片前更改文件名，以实现动画效果。</p><p><img src="/img/post/DJmini/gif%E5%9B%BE%E7%89%87%E5%90%8D%E5%BA%8F%E5%88%97.png" alt="gif图片名序列" title="gif图片名序列"></p><h6 id="公有-3"><a href="#公有-3" class="headerlink" title="公有"></a>公有</h6><p>帧间隔数组，存储每个GIF动画的帧间隔时间：int* dt &#x3D; new int(gifnum + 1);<br>记录播放到第几个GIF动画：int gifindex &#x3D; 1;</p><h5 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h5><h6 id="公有-4"><a href="#公有-4" class="headerlink" title="公有"></a>公有</h6><p>构造函数<br>实现从父类Area类继承的纯虚函数，区域绘制函数<br>播放下一个GIF动画</p><h3 id="Playarea类"><a href="#Playarea类" class="headerlink" title="Playarea类"></a>Playarea类</h3><h4 id="成员-3"><a href="#成员-3" class="headerlink" title="成员"></a>成员</h4><h5 id="变量-3"><a href="#变量-3" class="headerlink" title="变量"></a>变量</h5><h6 id="公有-5"><a href="#公有-5" class="headerlink" title="公有"></a>公有</h6><p>音符命中率：float rightrate;<br>游戏进度：int percent &#x3D; 0;</p><h6 id="保护-3"><a href="#保护-3" class="headerlink" title="保护"></a>保护</h6><p>音符命中数：int score &#x3D; 0;<br>音符数组，存储生成的音符：Note* note[500] &#x3D; { 0 };<br>已生成音符数：int nowNum &#x3D; 0;</p><h5 id="函数-3"><a href="#函数-3" class="headerlink" title="函数"></a>函数</h5><h6 id="公有-6"><a href="#公有-6" class="headerlink" title="公有"></a>公有</h6><p>构造函数<br>生成音符<br>窗体中所有音符下移<br>判定是否命中音符<br>实现从父类Area类继承的纯虚函数，区域绘制函数</p><h3 id="类间关系"><a href="#类间关系" class="headerlink" title="类间关系"></a>类间关系</h3><p><img src="/img/post/DJmini/%E7%B1%BB%E9%97%B4%E5%85%B3%E7%B3%BB.png" alt="类间关系" title="类间关系"></p><h3 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h3><h4 id="各区域规划"><a href="#各区域规划" class="headerlink" title="各区域规划"></a>各区域规划</h4><p><img src="/img/post/DJmini/%E5%90%84%E5%8C%BA%E5%9F%9F%E8%A7%84%E5%88%92.png" alt="各区域规划" title="各区域规划"></p><h4 id="重要环节"><a href="#重要环节" class="headerlink" title="重要环节"></a>重要环节</h4><h5 id="GIF动画"><a href="#GIF动画" class="headerlink" title="GIF动画"></a>GIF动画</h5><p>加载各个GIF动画帧数，数组存储</p><p>加载各个GIF动画每帧间隔时间，数组存储</p><h5 id="背景音乐"><a href="#背景音乐" class="headerlink" title="背景音乐"></a>背景音乐</h5><p>加载并播放背景音乐</p><h4 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h4><h5 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h5><h6 id="定时器0"><a href="#定时器0" class="headerlink" title="定时器0"></a>定时器0</h6><p>根据当前GIF动画每帧间隔时间进行中断，调用区域绘制函数重绘动画播放区，实现单个GIF动画播放。</p><h6 id="定时器1"><a href="#定时器1" class="headerlink" title="定时器1"></a>定时器1</h6><p>控制每个GIF动画播放时长，触发后播放下一个GIF动画。</p><h6 id="定时器2"><a href="#定时器2" class="headerlink" title="定时器2"></a>定时器2</h6><p>根据倒计时动画每帧间隔时间进行中断，调用区域绘制函数重绘玩家操作区，实现动画播放。</p><h6 id="定时器3"><a href="#定时器3" class="headerlink" title="定时器3"></a>定时器3</h6><p>控制倒计时结束时间，触发后将一个全局布尔变量置真，意为开始游戏。</p><h6 id="定时器4"><a href="#定时器4" class="headerlink" title="定时器4"></a>定时器4</h6><p>控制生成音符时间，触发一次，利用随机数和Playarea类生成音符函数，随机生成0，1或2个音符，然后调用区域绘制函数重绘玩家操作区。</p><h6 id="定时器5"><a href="#定时器5" class="headerlink" title="定时器5"></a>定时器5</h6><p>每触发一次游戏进度+1，然后调用区域绘制函数重绘玩家操作区，从而实时显示游戏进度。</p><h6 id="定时器6"><a href="#定时器6" class="headerlink" title="定时器6"></a>定时器6</h6><p>每触发一次调用Playarea类窗体中所有音符下移的函数，然后调用区域绘制函数重绘玩家操作区，实现音符下落效果。</p><h6 id="定时器7"><a href="#定时器7" class="headerlink" title="定时器7"></a>定时器7</h6><p>游戏结束，停止动画播放，根据命中率，在动画播放区显示玩家最终评级。</p><h5 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h5><p>如果发生的事件为按下，则调用Playarea类中判定是否命中音符的函数。</p><h2 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h2><h4 id="Note类-1"><a href="#Note类-1" class="headerlink" title="Note类"></a>Note类</h4><h5 id="初始化音符信息"><a href="#初始化音符信息" class="headerlink" title="初始化音符信息"></a>初始化音符信息</h5><h6 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">initNote</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h6 id="函数实现"><a href="#函数实现" class="headerlink" title="函数实现"></a>函数实现</h6><p>通过rand生成随机数，mod2以后赋给style<br>通过rand生成随机数，mod4*音符宽度以后赋给nLeftRect<br>nLeftRect加上音符宽度赋给nLeftRect</p><h5 id="音符下落"><a href="#音符下落" class="headerlink" title="音符下落"></a>音符下落</h5><h6 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">movedown</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h6 id="函数实现-1"><a href="#函数实现-1" class="headerlink" title="函数实现"></a>函数实现</h6><p>nTopRect和nBottomRect均增加一定值，值越大，下落越快。</p><h5 id="绘制音符"><a href="#绘制音符" class="headerlink" title="绘制音符"></a>绘制音符</h5><h6 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawNote</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h6 id="函数实现-2"><a href="#函数实现-2" class="headerlink" title="函数实现"></a>函数实现</h6><ol><li><p>判断style的值。如果为0，则通过setPenColor和setBrushColor函数定义画笔画刷为蓝色；否则定义画笔画刷为紫色。</p></li><li><p>通过acllib库中绘制圆角矩形的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">roundrect</span>(nLeftRect,nTopRect,nRightRect,nBottomRect,nWidth,nHeight);</span><br></pre></td></tr></table></figure><p>绘制音符。</p></li></ol><h4 id="Area类-1"><a href="#Area类-1" class="headerlink" title="Area类"></a>Area类</h4><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><h6 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Area</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height);</span><br></pre></td></tr></table></figure><h6 id="函数实现-3"><a href="#函数实现-3" class="headerlink" title="函数实现"></a>函数实现</h6><p>将传入的x, y, width, height分别赋给this指针指向的x, y, width, height。</p><h5 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h5><p>函数原型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Area</span>(Area&amp; area);</span><br></pre></td></tr></table></figure><p>函数实现</p><p>将作为引用的area的x, y, width, height分别赋给x, y, width, height。</p><h5 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h5><p>函数原型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">Area</span>();</span><br></pre></td></tr></table></figure><p>函数实现</p><p>函数体为空。</p><h5 id="区域绘制函数"><a href="#区域绘制函数" class="headerlink" title="区域绘制函数"></a>区域绘制函数</h5><h6 id="函数原型-4"><a href="#函数原型-4" class="headerlink" title="函数原型"></a>函数原型</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">drawArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h6 id="函数实现-4"><a href="#函数实现-4" class="headerlink" title="函数实现"></a>函数实现</h6><p>声明为纯虚函数,函数体为空。</p><h4 id="GifArea类-1"><a href="#GifArea类-1" class="headerlink" title="GifArea类"></a>GifArea类</h4><h5 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h5><h6 id="函数原型-5"><a href="#函数原型-5" class="headerlink" title="函数原型"></a>函数原型</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">GifArea</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height,<span class="type">int</span> num,<span class="type">int</span>* Zhen,<span class="type">int</span>* Dt, <span class="type">int</span> Id);</span><br></pre></td></tr></table></figure><h6 id="函数实现-5"><a href="#函数实现-5" class="headerlink" title="函数实现"></a>函数实现</h6><p>将传入的x, y, width, height通过参数表传给从父类Area继承的成员变量x, y, width, height。</p><p>将传入的num, Zhen, Dt, Id分别赋给this指针指向的gifnum, zhen, dt, id。</p><h5 id="区域绘制函数-1"><a href="#区域绘制函数-1" class="headerlink" title="区域绘制函数"></a>区域绘制函数</h5><h6 id="函数原型-6"><a href="#函数原型-6" class="headerlink" title="函数原型"></a>函数原型</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawArea</span><span class="params">()</span></span>; <span class="comment">//从父类Area类继承的纯虚函数</span></span><br></pre></td></tr></table></figure><h6 id="函数实现-6"><a href="#函数实现-6" class="headerlink" title="函数实现"></a>函数实现</h6><ol><li>如果gifindex &lt;&#x3D; gifnum，即GIF未播放完，则进行下一步；否则函数执行结束；</li><li>gif图片名序列中的w1自增；</li><li>判断w1是否等于10，是则w1归0，w2+1;</li><li>判断w2是否等于10，是则w2归0，w3+1;</li><li>判断当前GIF是否播放完最后一帧，即w3 * 100 + w2 * 10 + w1是否等于zhen[gifindex]，是则w3和w2归0，w1置1;</li><li>将(id &#x2F; 10) + ‘0’赋给imgname[0]，将id % 10 + ‘0’赋给imgname[1]，将w3 + ‘0’赋给imgname[6]，将w2 + ‘0’赋给imgname[7]，将w1 + ‘0’赋给imgname[8]；</li><li>利用新的图片名数组，通过loadImage(imgname, &amp;img);加载下一帧图片；</li><li>通过putImageScale(&amp;img, x, y, width, height);进行图片绘制；</li><li>函数执行结束。</li></ol><h5 id="播放下一个GIF动画"><a href="#播放下一个GIF动画" class="headerlink" title="播放下一个GIF动画"></a>播放下一个GIF动画</h5><h6 id="函数原型-7"><a href="#函数原型-7" class="headerlink" title="函数原型"></a>函数原型</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h6 id="函数实现-7"><a href="#函数实现-7" class="headerlink" title="函数实现"></a>函数实现</h6><ol><li>将gif图片名序列中的w3,w2,w1置0；</li><li>如果gifindex &lt;&#x3D; gifnum，即GIF未播放完，则进行下一步；否则函数执行结束；</li><li>当前gif图片序号gifindex自增，gif图片名序列中的v1自增；</li><li>判断v1是否等于10，是则v1归0，v2+1;</li><li>将v2 + ‘0’赋给imgname[3]，将v1 + ‘0’赋给imgname[4]；</li><li>函数执行结束。</li></ol><h4 id="Playarea类-1"><a href="#Playarea类-1" class="headerlink" title="Playarea类"></a>Playarea类</h4><h5 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h5><h6 id="函数原型-8"><a href="#函数原型-8" class="headerlink" title="函数原型"></a>函数原型</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Playarea</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> height);</span><br></pre></td></tr></table></figure><h6 id="函数实现-8"><a href="#函数实现-8" class="headerlink" title="函数实现"></a>函数实现</h6><p> 将传入的x, y, width, height通过参数表传给从父类Area继承的成员变量x, y, width, height。</p><h5 id="生成音符"><a href="#生成音符" class="headerlink" title="生成音符"></a>生成音符</h5><h6 id="函数原型-9"><a href="#函数原型-9" class="headerlink" title="函数原型"></a>函数原型</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createNote</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h6 id="函数实现-9"><a href="#函数实现-9" class="headerlink" title="函数实现"></a>函数实现</h6><ol><li>new一个Note类的对象，并将其地址存放到Playarea类的note[nowNum]成员中；</li><li>通过note[nowNum]调用Note类的initNote();函数，初始化新的音符；</li><li>表示已生成音符数的nowNum自增。</li></ol><h5 id="所有音符下移"><a href="#所有音符下移" class="headerlink" title="所有音符下移"></a>所有音符下移</h5><h6 id="函数原型-10"><a href="#函数原型-10" class="headerlink" title="函数原型"></a>函数原型</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h6 id="函数实现-10"><a href="#函数实现-10" class="headerlink" title="函数实现"></a>函数实现</h6><ol><li>循环判断所有已生成音符的note地址是否为空；</li><li>地址为空，说明音符已消失；否则，调用Note类的movedown();函数，使该音符下落；</li><li>判断该音符的上边沿纵坐标是否超出窗体，超出则delete掉该音符。</li></ol><h5 id="判定是否命中音符"><a href="#判定是否命中音符" class="headerlink" title="判定是否命中音符"></a>判定是否命中音符</h5><h6 id="函数原型-11"><a href="#函数原型-11" class="headerlink" title="函数原型"></a>函数原型</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> key)</span></span>;</span><br></pre></td></tr></table></figure><h6 id="函数实现-11"><a href="#函数实现-11" class="headerlink" title="函数实现"></a>函数实现</h6><ol><li>通过Acllib库的loadSound(“敲击.wav”, &amp;hit);函数加载命中音效；</li><li>以传入参数key为关键字，运用switch语句进行按键判断；</li><li>每个case语句中的判断逻辑大致为：所有已生成且未消失的音符下边沿纵坐标是否超过判定线；如果成立，进一步判断该音符的音轨和颜色是否和按键相匹配。若均满足，则命中数加一，delete掉该音符，并播放命中音效。</li></ol><h5 id="区域绘制函数-2"><a href="#区域绘制函数-2" class="headerlink" title="区域绘制函数"></a>区域绘制函数</h5><h6 id="函数原型-12"><a href="#函数原型-12" class="headerlink" title="函数原型"></a>函数原型</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawArea</span><span class="params">()</span></span>;<span class="comment">//从父类Area类继承的纯虚函数</span></span><br></pre></td></tr></table></figure><h6 id="函数实现-12"><a href="#函数实现-12" class="headerlink" title="函数实现"></a>函数实现</h6><ol><li>先用loadImage();putImageScale();绘制背景；</li><li>通过循环，调用drawNote();函数绘制所有已生成且未消失的音符；</li><li>通过setTextBkColor();setTextColor();setTextSize();设置好文本绘制参数；</li><li>调用paintText();绘制命中率和游戏进度。</li></ol><h4 id="全局函数"><a href="#全局函数" class="headerlink" title="全局函数"></a>全局函数</h4><h5 id="加载各个GIF动画帧数"><a href="#加载各个GIF动画帧数" class="headerlink" title="加载各个GIF动画帧数"></a>加载各个GIF动画帧数</h5><h6 id="函数原型-13"><a href="#函数原型-13" class="headerlink" title="函数原型"></a>函数原型</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">loadzhen</span><span class="params">(<span class="type">int</span>* zhen)</span></span>;</span><br></pre></td></tr></table></figure><h6 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h6><p>传入一个整型数组的地址，将各个GIF动画帧数存放进该数组。</p><h5 id="加载各个GIF动画每帧间隔时间"><a href="#加载各个GIF动画每帧间隔时间" class="headerlink" title="加载各个GIF动画每帧间隔时间"></a>加载各个GIF动画每帧间隔时间</h5><h6 id="函数原型-14"><a href="#函数原型-14" class="headerlink" title="函数原型"></a>函数原型</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">loaddt</span><span class="params">(<span class="type">int</span>* dt)</span></span>;</span><br></pre></td></tr></table></figure><h6 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h6><p>传入一个整型数组的地址，将各个GIF动画每帧间隔时间存放进该数组。</p><h4 id="窗体"><a href="#窗体" class="headerlink" title="窗体"></a>窗体</h4><h6 id="函数原型-15"><a href="#函数原型-15" class="headerlink" title="函数原型"></a>函数原型</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">initWindow</span>(<span class="type">const</span> <span class="type">char</span> title[], <span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> width, <span class="type">int</span> height);</span><br></pre></td></tr></table></figure><h6 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h6><p>生成程序窗体。</p><p>title : 窗口标题。</p><p>left : 窗口左上角横坐标，若不希望指定窗口位置，可传入 DEFAULT。 </p><p>top : 窗口左上角纵坐标，若不希望指定窗口位置，可传入 DEFAULT。 </p><p>width : 窗口可绘制区域的宽度。 height : 窗口可绘制区域的高度。</p><h4 id="背景音乐-1"><a href="#背景音乐-1" class="headerlink" title="背景音乐"></a>背景音乐</h4><h5 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h5><p>从文件中加载声音文件，第一个参数为文件名，第二个参数为指向一个ACL_Sound结构的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">loadSound</span>(<span class="string">&quot;FirstKiss.mp3&quot;</span>, &amp;winsound);</span><br></pre></td></tr></table></figure><h5 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h5><p>第二个参数非零时，音乐将循环播放。否则只播放一遍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">playSound</span>(winsound, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="定时器-1"><a href="#定时器-1" class="headerlink" title="定时器"></a>定时器</h4><h5 id="注册定时器中断"><a href="#注册定时器中断" class="headerlink" title="注册定时器中断"></a>注册定时器中断</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">registerTimerEvent</span>(timerEvent);</span><br></pre></td></tr></table></figure><h5 id="开启定时器"><a href="#开启定时器" class="headerlink" title="开启定时器"></a>开启定时器</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">startTimer</span>(<span class="type">int</span> timerID, <span class="type">int</span> timeinterval);</span><br></pre></td></tr></table></figure><ol><li>定时器时间间隔单位为毫秒。设置定时器后，每经过 timeinterval 毫秒时间，便会触发 timer 事件。</li><li>可以使用多个 timer，ID 建议使用从 0 开始的整数。 </li><li>当 timeinterval 设置为 0 时，定时器会在程序空闲时（没有键盘、鼠标输入，且上次 timer 事件已经处理）触发。 </li><li>timer 的时间精度在 10ms数量级，当设置的时间间隔小于 10ms 时，实际间隔会在 10ms 以上。</li></ol><h5 id="定时器事件"><a href="#定时器事件" class="headerlink" title="定时器事件"></a>定时器事件</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">timerEvent</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>通过switch 语句对id进行判断，从而得知是第几个定时器触发 timer 事件，进而执行相应语句，时序性地实现各项功能。</p><h4 id="键盘-1"><a href="#键盘-1" class="headerlink" title="键盘"></a>键盘</h4><h5 id="注册键盘中断"><a href="#注册键盘中断" class="headerlink" title="注册键盘中断"></a>注册键盘中断</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">registerKeyboardEvent</span>(keyEvent);</span><br></pre></td></tr></table></figure><h5 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h5><p>第一个参数为按键的虚拟键码（注意：不是 ASCII 码）。第二个参数为发生的事件（按下或弹起）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">keyEvent</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> event)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>通过对象调用Playarea类的judge(key);函数，判定是否命中音符。</p><h2 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h2><h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><p>黑盒测试。主要是对软件界面和软件功能进行测试。检查程序的功能是否能够按照规范说明准确无误的运行。</p><h3 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h3><h4 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h4><h5 id="执行程序"><a href="#执行程序" class="headerlink" title="执行程序"></a>执行程序</h5><h6 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h6><p>双击.exe文件</p><h6 id="实际效果"><a href="#实际效果" class="headerlink" title="实际效果"></a>实际效果</h6><p><img src="/img/post/DJmini/%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F.png" alt="执行程序" title="执行程序"></p><h5 id="倒计时"><a href="#倒计时" class="headerlink" title="倒计时"></a>倒计时</h5><h6 id="预期效果"><a href="#预期效果" class="headerlink" title="预期效果"></a>预期效果</h6><p>播放5秒倒计时动画，倒计时结束，游戏开始；</p><h6 id="实际效果-1"><a href="#实际效果-1" class="headerlink" title="实际效果"></a>实际效果</h6><p><img src="/img/post/DJmini/%E5%80%92%E8%AE%A1%E6%97%B6.png" alt="倒计时" title="倒计时"></p><h5 id="游戏过程"><a href="#游戏过程" class="headerlink" title="游戏过程"></a>游戏过程</h5><h6 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h6><p>按下相应按键</p><h6 id="预期效果-1"><a href="#预期效果-1" class="headerlink" title="预期效果"></a>预期效果</h6><ol><li>音符自动生成，下落。</li><li>玩家按键击打，命中则音符消失，伴随命中音效，命中率增加；</li><li>游戏区右上角实时显示命中率和游戏进度；</li><li>动画区播放GIF动画。</li></ol><h6 id="实际效果-2"><a href="#实际效果-2" class="headerlink" title="实际效果"></a>实际效果</h6><p><img src="/img/post/DJmini/%E6%B8%B8%E6%88%8F%E8%BF%87%E7%A8%8B.png" alt="游戏过程" title="游戏过程"></p><h5 id="游戏结束"><a href="#游戏结束" class="headerlink" title="游戏结束"></a>游戏结束</h5><h6 id="预期效果-2"><a href="#预期效果-2" class="headerlink" title="预期效果"></a>预期效果</h6><p>游戏进度到达100%，游戏结束。片刻后在动画播放区显示评级，伴有音效。</p><h6 id="实际效果-3"><a href="#实际效果-3" class="headerlink" title="实际效果"></a>实际效果</h6><p><img src="/img/post/DJmini/%E8%AF%84%E7%BA%A7.png" alt="评级" title="评级"></p><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>程序较好地实现了预期功能。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重建二叉树</title>
      <link href="/2020/11/08/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/11/08/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a><strong>问题描述</strong></h5><p>用先序序列和中序序列构建二叉树，采用二叉链表存储。编写递归算法，交换二叉树的左右子树，<br>输出新二叉树按先序遍历得到的结果。</p><p>提交格式：实现void solve(int n, int *preOrder, int *inOrder, int *outOrder)函数。<br>函数参数为序列长度n、先序序列preOrder、中序序列inOrder和输出序列outOrder。1&lt;&#x3D;n&lt;&#x3D;1000000，树的深度&lt;&#x3D;2000。请不要printf输出任何内容。</p><h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a><strong>实现思路</strong></h5><h6 id="测试主函数"><a href="#测试主函数" class="headerlink" title="测试主函数"></a>测试主函数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="type">int</span>* pre = (<span class="type">int</span>*)<span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* in = (<span class="type">int</span>*)<span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (in == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* out = (<span class="type">int</span>*)<span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (out == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;pre[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;in[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    solve(N, pre, in, out);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="solve函数"><a href="#solve函数" class="headerlink" title="solve函数"></a>solve函数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>* preOrder, <span class="type">int</span>* inOrder, <span class="type">int</span>* outOrder)</span></span><br><span class="line">&#123;</span><br><span class="line">    PBiTNode root=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || preOrder==<span class="literal">NULL</span>|| inOrder==<span class="literal">NULL</span>|| outOrder==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        CreatepostBiTree(preOrder, inOrder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">        PreOrder(root, outOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="CreatepostBiTree函数"><a href="#CreatepostBiTree函数" class="headerlink" title="CreatepostBiTree函数"></a>CreatepostBiTree函数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreatepostBiTree</span><span class="params">(<span class="type">int</span> preord[], <span class="type">int</span> inord[], <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k, <span class="type">int</span> h, PBiTNode &amp;t)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 先序序列中从i到j，中序序列从k到h，建立一棵二叉树放在t中*/</span></span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    t = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">        t-&gt;data = preord[i];  <span class="comment">/*二叉树的根*/</span></span><br><span class="line">        m = k;</span><br><span class="line">        <span class="keyword">while</span> (inord[m] != preord[i]) m++; <span class="comment">/*在中序序列中定位树的根*/</span></span><br><span class="line">        <span class="comment">/*递归调用建立左子树*/</span></span><br><span class="line">        <span class="keyword">if</span> (m == k) t-&gt;lchild = <span class="literal">NULL</span>;    <span class="comment">/*左子树空*/</span></span><br><span class="line">        <span class="keyword">else</span> CreatepostBiTree(preord, inord, i + <span class="number">1</span>, i + m - k, k, m - <span class="number">1</span>, (t-&gt;lchild));</span><br><span class="line">        <span class="comment">/*递归调用建立右子树*/</span></span><br><span class="line">        <span class="keyword">if</span> (m == h) t-&gt;rchild = <span class="literal">NULL</span>;   <span class="comment">/*右子树空*/</span></span><br><span class="line">        <span class="keyword">else</span> CreatepostBiTree(preord, inord, i + m - k + <span class="number">1</span>, j, m + <span class="number">1</span>, h, (t-&gt;rchild));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="PreOrder函数"><a href="#PreOrder函数" class="headerlink" title="PreOrder函数"></a>PreOrder函数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(PBiTNode bt, <span class="type">int</span>* out1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt != <span class="literal">NULL</span>) &#123; <span class="comment">/* 如果bt为空，结束*/</span></span><br><span class="line">        out1[s++] = bt-&gt;data;  <span class="comment">/*访问根结点*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, bt-&gt;data);</span><br><span class="line">        PreOrder(bt-&gt;rchild, out1);   <span class="comment">/*先序遍历左子树（递归调用）*/</span></span><br><span class="line">        PreOrder(bt-&gt;lchild, out1);   <span class="comment">/*先序遍历右子树（递归调用）*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, * PBiTNode;</span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(PBiTNode bt, <span class="type">int</span>* out1)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatepostBiTree</span><span class="params">(<span class="type">int</span> preord[], <span class="type">int</span> inord[], <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k, <span class="type">int</span> h, PBiTNode &amp;t)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>* preOrder, <span class="type">int</span>* inOrder, <span class="type">int</span>* outOrder)</span></span><br><span class="line">&#123;</span><br><span class="line">    PBiTNode root=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || preOrder==<span class="literal">NULL</span>|| inOrder==<span class="literal">NULL</span>|| outOrder==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        CreatepostBiTree(preOrder, inOrder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">        PreOrder(root, outOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatepostBiTree</span><span class="params">(<span class="type">int</span> preord[], <span class="type">int</span> inord[], <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k, <span class="type">int</span> h, PBiTNode &amp;t)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 先序序列中从i到j，中序序列从k到h，建立一棵二叉树放在t中*/</span></span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    t = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">        t-&gt;data = preord[i];  <span class="comment">/*二叉树的根*/</span></span><br><span class="line">        m = k;</span><br><span class="line">        <span class="keyword">while</span> (inord[m] != preord[i]) m++; <span class="comment">/*在中序序列中定位树的根*/</span></span><br><span class="line">        <span class="comment">/*递归调用建立左子树*/</span></span><br><span class="line">        <span class="keyword">if</span> (m == k) t-&gt;lchild = <span class="literal">NULL</span>;    <span class="comment">/*左子树空*/</span></span><br><span class="line">        <span class="keyword">else</span> CreatepostBiTree(preord, inord, i + <span class="number">1</span>, i + m - k, k, m - <span class="number">1</span>, (t-&gt;lchild));</span><br><span class="line">        <span class="comment">/*递归调用建立右子树*/</span></span><br><span class="line">        <span class="keyword">if</span> (m == h) t-&gt;rchild = <span class="literal">NULL</span>;   <span class="comment">/*右子树空*/</span></span><br><span class="line">        <span class="keyword">else</span> CreatepostBiTree(preord, inord, i + m - k + <span class="number">1</span>, j, m + <span class="number">1</span>, h, (t-&gt;rchild));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(PBiTNode bt, <span class="type">int</span>* out1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt != <span class="literal">NULL</span>) &#123; <span class="comment">/* 如果bt为空，结束*/</span></span><br><span class="line">        out1[s++] = bt-&gt;data;  <span class="comment">/*访问根结点*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, bt-&gt;data);</span><br><span class="line">        PreOrder(bt-&gt;rchild, out1);   <span class="comment">/*先序遍历左子树（递归调用）*/</span></span><br><span class="line">        PreOrder(bt-&gt;lchild, out1);   <span class="comment">/*先序遍历右子树（递归调用）*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="type">int</span>* pre = (<span class="type">int</span>*)<span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* in = (<span class="type">int</span>*)<span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (in == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* out = (<span class="type">int</span>*)<span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (out == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;pre[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;in[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    solve(N, pre, in, out);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a><strong>实现要点</strong></h5><p>1.函数嵌套使用时，参数值的传递。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreatepostBiTree</span><span class="params">(<span class="type">int</span> preord[], <span class="type">int</span> inord[], <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k, <span class="type">int</span> h, PBiTNode &amp;t)</span></span><br></pre></td></tr></table></figure><p>若把t之前的&amp;去掉，则无法完成双向传递，CreatepostBiTree函数执行完后root的值并未修改，运行出错。</p><p>2.malloc动态分配内存之后，注意判断是否分配成功</p><p>3.solve函数调用CreatepostBiTree函数时，注意根据序列preord和inord的实际情况传入i，j，k，h的实参</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CreatepostBiTree(preOrder, inOrder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br></pre></td></tr></table></figure><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><h6 id="样例测试"><a href="#样例测试" class="headerlink" title="样例测试"></a><strong>样例测试</strong></h6><p>输入样例：<br>n&#x3D;5,preOrder&#x3D;{1,2,3,4,5},inOrder&#x3D;{3,2,4,1,5}<br>输出样例：<br>outOrder&#x3D;{1,5,2,4,3}</p><p><img src="/img/post/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%A0%B7%E4%BE%8B%E6%B5%8B%E8%AF%95.png" alt="样例测试" title="样例测试"></p><h6 id="提交测试"><a href="#提交测试" class="headerlink" title="提交测试"></a>提交测试</h6><p><img src="/img/post/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%8F%90%E4%BA%A4%E6%B5%8B%E8%AF%95.png" alt="提交测试" title="提交测试"></p><h5 id="进一步思考"><a href="#进一步思考" class="headerlink" title="进一步思考"></a>进一步思考</h5><p><img src="/img/post/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%B1%82%E5%8A%A9.png" alt="求助" title="求助"></p><p>怎么办呢。。怎么办呢。。算了，明天又想，上床睡觉。</p><p>我闭上眼，横竖睡不着，翻来覆去地想，脑中浮现着代码，最后从一行行代码间看出了满屏写满了两个大字——哈希！</p><p>我惊坐而起，爬下床去，慌忙翻开电脑，把中序遍历的序号进行了Hash👨‍💻</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> inordindex[<span class="number">100000000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            inordindex[inOrder[i]] = i;</span><br></pre></td></tr></table></figure><h5 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, * PBiTNode;</span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> inordindex[<span class="number">100000000</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(PBiTNode bt, <span class="type">int</span>* out1)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatepostBiTree</span><span class="params">(<span class="type">int</span> preord[], <span class="type">int</span> inord[], <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k, <span class="type">int</span> h, PBiTNode &amp;t)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>* preOrder, <span class="type">int</span>* inOrder, <span class="type">int</span>* outOrder)</span></span><br><span class="line">&#123;</span><br><span class="line">    PBiTNode root=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span> || preOrder==<span class="literal">NULL</span>|| inOrder==<span class="literal">NULL</span>|| outOrder==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            inordindex[inOrder[i]] = i;</span><br><span class="line">        CreatepostBiTree(preOrder, inOrder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>, root);</span><br><span class="line">        PreOrder(root, outOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatepostBiTree</span><span class="params">(<span class="type">int</span> preord[], <span class="type">int</span> inord[], <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k, <span class="type">int</span> h, PBiTNode &amp;t)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 先序序列中从i到j，中序序列从k到h，建立一棵二叉树放在t中*/</span></span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    t = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">        t-&gt;data = preord[i];  <span class="comment">/*二叉树的根*/</span></span><br><span class="line">        m = inordindex[preord[i]];  <span class="comment">/*在中序序列中定位树的根*/</span></span><br><span class="line">        <span class="comment">/*递归调用建立左子树*/</span></span><br><span class="line">        <span class="keyword">if</span> (m == k) t-&gt;lchild = <span class="literal">NULL</span>;    <span class="comment">/*左子树空*/</span></span><br><span class="line">        <span class="keyword">else</span> CreatepostBiTree(preord, inord, i + <span class="number">1</span>, i + m - k, k, m - <span class="number">1</span>, (t-&gt;lchild));</span><br><span class="line">        <span class="comment">/*递归调用建立右子树*/</span></span><br><span class="line">        <span class="keyword">if</span> (m == h) t-&gt;rchild = <span class="literal">NULL</span>;   <span class="comment">/*右子树空*/</span></span><br><span class="line">        <span class="keyword">else</span> CreatepostBiTree(preord, inord, i + m - k + <span class="number">1</span>, j, m + <span class="number">1</span>, h, (t-&gt;rchild));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(PBiTNode bt, <span class="type">int</span>* out1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt != <span class="literal">NULL</span>) &#123; <span class="comment">/* 如果bt为空，结束*/</span></span><br><span class="line">        out1[s++] = bt-&gt;data;  <span class="comment">/*访问根结点*/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, bt-&gt;data);</span><br><span class="line">        PreOrder(bt-&gt;rchild, out1);   <span class="comment">/*先序遍历左子树（递归调用）*/</span></span><br><span class="line">        PreOrder(bt-&gt;lchild, out1);   <span class="comment">/*先序遍历右子树（递归调用）*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> N;</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="type">int</span>* pre = (<span class="type">int</span>*)<span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* in = (<span class="type">int</span>*)<span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (in == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>* out = (<span class="type">int</span>*)<span class="built_in">malloc</span>(N * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (out == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;pre[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;in[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    solve(N, pre, in, out);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/post/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/ac.png" alt="ac" title="ac"></p><p>舒服了😃</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 二叉树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“排序算法”小结</title>
      <link href="/2020/10/31/%E2%80%9C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E2%80%9D%E5%B0%8F%E7%BB%93/"/>
      <url>/2020/10/31/%E2%80%9C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E2%80%9D%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/0ziyuan/pic_bed/main/img/20201031152128.jpeg"></p><span id="more"></span><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>本文转载自微信公众号 <strong>程序员小灰</strong>，系其原创文章，转载已征得作者本人同意，少许改动未涉及核心内容😀</p><p>CSDN地址：<a href="https://blog.csdn.net/bjweimengshu/article/details/103573147">https://blog.csdn.net/bjweimengshu/article/details/103573147</a></p><h4 id="三个梯队"><a href="#三个梯队" class="headerlink" title="三个梯队"></a>三个梯队</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRrMWpNMG9WRTh3bW5MRm1PZlVaaWJJQldpYmV5Y1phekRlaWFzZnJtVUJjcWdLZFBLWk1SYVJsYW53LzY0MD93eF9mbXQ9anBlZw?x-oss-process=image/format,png"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRrUm9OeXRpYmd0NGJnYWxjNDR1OUhHN2lhYndEQXpUWW11R0xVN1UyamJrbWtjOWJJMWVuMzJmY3cvNjQwP3d4X2ZtdD1qcGVn?x-oss-process=image/format,png"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRrb2liMHp1aWF1WE82TDFsb2lhWWRKZVZLdkxEdUVDN2p3YmVnU1c2UlVETHhnOEZ2WVBnTTk4d293LzY0MD93eF9mbXQ9anBlZw?x-oss-process=image/format,png"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRreUI4c0x5V2dhMVZmREVPWDBIUHlzcGZ0eXoyN3hNUmlhS3cyVE1TNUpIakxWWEFuaWFoVTVZaWJnLzY0MD93eF9mbXQ9anBlZw?x-oss-process=image/format,png"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRrUURBMHJmVXZSSFhCYWZhQkdNTFdCQUwzZWMzc1RYclFvVXRkaWFoV1dvSEtST2ljZUV6V3B0VWcvNjQwP3d4X2ZtdD1qcGVn?x-oss-process=image/format,png"></p><h4 id="第三梯队"><a href="#第三梯队" class="headerlink" title="第三梯队"></a>第三梯队</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRrRm1maWMwUFlTeUFWNjVQU2RUZWRoUmlhZ2ZwUndkZUJ5aWNMQWFNT2JRajhKR29NWlFPTWZscDBnLzY0MD93eF9mbXQ9anBlZw?x-oss-process=image/format,png"></p><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h5><p><a href="http://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&chksm=8c99fb70bbee72668cad223892ad362525d215e7f936458f99dd289eb82981099359310e9e54&idx=1&mid=2653194666&scene=21&sn=69ce32870c0b981c40b1e124fbb6bba8#wechat_redirect">漫画：什么是冒泡排序？</a></p><h5 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a><strong>选择排序</strong></h5><p><a href="http://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&chksm=8c99e855bbee61439086680ceefef33c56038c5d552ae64c1d6135abe467b617aa62f4934f36&idx=1&mid=2653198991&scene=21&sn=7f98d59898a911e1425baa6cc180c598#wechat_redirect">漫画：什么是选择排序？</a></p><h5 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><strong>插入排序</strong></h5><p><a href="https://blog.csdn.net/bjweimengshu/article/details/99372874">漫画：什么是插入排序？</a></p><h5 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a><strong>鸡尾酒排序</strong></h5><p>冒泡排序的变种</p><p><a href="http://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&chksm=8c99f87dbbee716b531df3fcf5882998f28794aad5609f225883d6c2dc71ba51b8a5126b32be&idx=2&mid=2653194919&scene=21&sn=f473bc9e0da124a303312a11902e2f52#wechat_redirect">漫画：什么是鸡尾酒排序？</a></p><h5 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h5><p>平均时间复杂度都是<strong>O（n^2）</strong></p><h5 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRrcVF4VTk1bG9WUXg5TjN3cGhQbU1MamhGa2ZnT0NqamVDVjlacXg2NlFIeGlhT1J4ZzNRTndEUS82NDA_d3hfZm10PWpwZWc?x-oss-process=image/format,png"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRrVmNKejNEMGliUE0ySkhJR3R3U2xZQ2lhRXJPZmxndHNOYm9EOGU1NEhWSVpJQmlhUWJoaWNKeW4xZy82NDA_d3hfZm10PWpwZWc?x-oss-process=image/format,png"></p><h6 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h6><p><strong>冒泡排序</strong>和<strong>插入排序</strong>的元素比较交换次数取决于原始数组的<strong>有序程度</strong>。</p><p>如果原始数组本来已经接近有序，只需要较少的比较交换次数即可完成排序。比如下面这个数组，只有7和8是逆序的：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRreTE4VXk0Q3d2czVJdW5OZ2Zoc2libUx4d1IwQTdJWWliaWF6V1RpYjlCRVJzWlBpYUNKTzJONWJidlEvNjQwP3d4X2ZtdD1wbmc?x-oss-process=image/format,png"></p><p>如果原始数组大部分元素无序，则需要较多的比较交换次数。比如下面这个数组，绝大部分元素都是无序的：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRrWEVwMW5rREJjNUVrYWRaajE4YkFOVXBIaWFEOXprVEFFbm5QSzBzYTRIbEFubVBpYlg3R2gxZkEvNjQwP3d4X2ZtdD1wbmc?x-oss-process=image/format,png"></p><p>在此基础上，<strong>插入排序的性能略高于冒泡排序</strong>。为什么这么说呢？因为冒泡排序每两个元素之间的交换是彼此独立的，比如A和B交换，B和C交换，C和D交换：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRrb1dpYUZsVWliSkprNXRBOUNtdDJVbVEzeVE5a1VCbWtzNnd4a3RuUFRWaklaRTF4NlM3QUlEOXcvNjQwP3d4X2ZtdD1wbmc?x-oss-process=image/format,png"></p><p>而插入排序的元素交换是连续的，比如把B赋值给A，把C赋值给B，把D赋值给C，最后把A赋值给D：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRrT1B3cFY1YWFKMmliN0k4ZXlIMDhNb1dMc0gyZHFQbmhRTmNoNG40eEF1dE92Vzhjb0I5bmJsdy82NDA_d3hfZm10PXBuZw?x-oss-process=image/format,png"></p><p>显然，归并排序的连续交换方式省去了许多无谓的交换操作。</p><p>再来说说选择排序，选择排序和前面两者不太一样，<strong>它的元素比较交换次数是固定的，和原始数组的有序程度无关</strong>。</p><p>因此，<strong>当原始数组接近有序时，插入排序性能最优；当原始数组大部分元素无序时，选择排序性能最优</strong>。</p><h6 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h6><p><strong>冒泡排序和插入排序是稳定排序</strong>，值相同的元素在排序后仍然保持原本的先后顺序。</p><p><strong>选择排序是不稳定排序</strong>，值相同的元素在排序后不一定保持原本的先后顺序。</p><h4 id="第二梯队"><a href="#第二梯队" class="headerlink" title="第二梯队"></a>第二梯队</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRrc0REYmhOV1g0a2JpYmliRWpWOWlhWmljazcwOGljSHBZaWNUMUN6MXhoMXpGTGZZNDMzZkZHd2VWQ2dnLzY0MD93eF9mbXQ9anBlZw?x-oss-process=image/format,png"></p><h5 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a><strong>希尔排序</strong></h5><p><a href="https://blog.csdn.net/bjweimengshu/article/details/100681410">漫画：什么是希尔排序？</a></p><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><strong>快速排序</strong></h5><p><a href="http://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&chksm=8c99f9f8bbee70eef627d0f5e5b80a604221abb3a1b5617b397fa178582dcb063c9fb6f904b3&idx=1&mid=2653195042&scene=21&sn=2b0915cd2298be9f2163cc90a3d464da#wechat_redirect">漫画：什么是快速排序？</a></p><h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a><strong>归并排序</strong></h5><p><a href="https://blog.csdn.net/bjweimengshu/article/details/102384930">漫画：什么是归并排序？</a></p><h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a><strong>堆排序</strong></h5><p><a href="http://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&chksm=8c99f912bbee7004625a0b204acc8484acbdf4f1b18953e7ff5acbea958ec002d8c8ea072792&idx=1&mid=2653195208&scene=21&sn=e3d6559402148458f0a4993b47d8bc6f#wechat_redirect">漫画：什么是堆排序？</a></p><h5 id="共同点-1"><a href="#共同点-1" class="headerlink" title="共同点"></a>共同点</h5><p>它们的性能比第三梯队要高一个量级，其中希尔排序的平均时间复杂度最快可以达到<strong>O（n^1.3）</strong>，快速排序、归并排序、堆排序的平均时间复杂度是<strong>O（nlogn）</strong>。</p><h5 id="差异-1"><a href="#差异-1" class="headerlink" title="差异"></a>差异</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRrbGczWHdTd3E4aWNwV0VTUTY2S3FlenFkYkFKVkFpY2VUcEh5M0E5NWljT2ljaWJ5QW9uQjU2OEtENlEvNjQwP3d4X2ZtdD1qcGVn?x-oss-process=image/format,png"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRrZDJRNmljVXNQSFgxQ3U3OUlrVThpYjl2RUVpY0lpYVB5amlhamhMb0VXV2phR3JOR0tZUGliV2ZVUTlBLzY0MD93eF9mbXQ9anBlZw?x-oss-process=image/format,png"></p><h6 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h6><p>虽然快速排序的平均时间复杂度是O（nlogn），但是在极端情况下，<strong>最坏时间复杂度是O（n^2）</strong>。</p><p>而归并排序和堆排序的时间复杂度稳定在O（nlogn）。</p><p>至于平均时间复杂度，虽然三者同样都是O（nlogn），但是堆排序比前两者的性能略低一些。为什么呢？主要是由于<strong>二叉堆的父子节点在内存中并不连续</strong>。</p><p>在访问内存数据时，对于顺序存储的数据，读写效率往往是最高的。根据CPU的<strong>空间局部性原理</strong>，CPU在每次访问数据的时候，会把内存中相邻的数据也一并存入缓存。这样一来，CPU以后再访问邻近的数据就不需要重新访问内存，而是访问CPU缓存，从而大大提升了程序执行的效率。</p><p>下图是有些夸张的示意：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9OdE81c2lhbEpaR3B2bE50ZmNNbFV2akRmR3c1N2ZHeWZIR3lVYVpVcW9FYWd0OXhQTGdBcVY2YkpGQVlFNVpYd0RxWmxybHdlRkhZMjYxUmNYd2ZMYXcvNjQwP3d4X2ZtdD1wbmc?x-oss-process=image/format,png"></p><p>在堆排序的过程中，常常需要父子节点之间进行比较和交换，而父子节点在数组中的位置并不是相邻，而是相差两倍左右：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRrNkFUZ0JJZkJBbjJwRnJNYWVjaGZJTGFTUno4bmpMU3o5YWliNWpJWEFFZ2VzbGlhNENZdWdPNlEvNjQwP3d4X2ZtdD1wbmc?x-oss-process=image/format,png"></p><p>反观快速排序和归并排序，无论是快速排序中把元素移动到pivot两侧，还是进行归并排序中的merge操作，都是按照数组元素的自然顺序依次进行比较和交换操作。</p><p>因此，<strong>堆排序的平均性能比快速排序和归并排序略低。</strong></p><h6 id="排序的稳定性-1"><a href="#排序的稳定性-1" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h6><p>归并排序是<strong>稳定排序</strong>，快速排序和堆排序是<strong>不稳定排序</strong>。</p><p>此外，快速排序和堆排序是<strong>原地排序</strong>，不需要开辟额外空间。而归并排序是<strong>非原地排序</strong>，在merge操作的时候需要借助额外的辅助数组来完成。</p><h4 id="第一梯队"><a href="#第一梯队" class="headerlink" title="第一梯队"></a>第一梯队</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRrM2t3dWM3M3VRWktURFBuU2NHYUtVYWo4aWJlVWptbFhXVkdpYjltMVA5UUJXWGxNM3NtdWdVcEEvNjQwP3d4X2ZtdD1qcGVn?x-oss-process=image/format,png"></p><h5 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a><strong>计数排序</strong></h5><p><a href="http://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&chksm=8c99ffd7bbee76c1d2e2e9b198259795285ec2c305d3613a5e39622195fd1c32bb6dbe52fa08&idx=1&mid=2653195533&scene=21&sn=02918dc51b07837ce1119f00d7900dbc#wechat_redirect">漫画：什么是计数排序？</a></p><h5 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a><strong>桶排序</strong></h5><p><a href="http://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&chksm=8c99ffe4bbee76f23d16ac1e0c7feeb16654ebb75e40d92c911bffa113059f52ce4508281a55&idx=1&mid=2653195582&scene=21&sn=1e7ece4e48c20fb994e2cefdcbdce4c5#wechat_redirect">漫画：什么是桶排序？</a></p><h5 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a><strong>基数排序</strong></h5><p><a href="https://blog.csdn.net/bjweimengshu/article/details/102908292">漫画：什么是基数排序？</a></p><h5 id="共同点-2"><a href="#共同点-2" class="headerlink" title="共同点"></a>共同点</h5><p>它们的性能比第二梯队又要高出一个量级，都属于<strong>线性时间复杂度</strong>的排序算法。</p><p>三种排序算法都属于<strong>稳定排序</strong>。</p><h5 id="差异-2"><a href="#差异-2" class="headerlink" title="差异"></a>差异</h5><p>虽然计数排序、桶排序、基数排序同为线性排序算法，但它们的时间复杂度有着很大不同：</p><p>计数排序的时间复杂度是<strong>O（n+m）</strong>，其中m是原始数组的整数范围。</p><p>桶排序的时间复杂度是<strong>O（n）</strong>，这是在分桶数量是n的前提下。</p><p>基数排序的时间复杂度是<strong>O（k（n+m））</strong>，其中k是元素的最大位数，m是每一位的取值范围。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRrck91R2ljb0lMVUNua1JlNUdaR0wyRlZBZEdZdmRZcmFzVFhvRzZqZkg5WkIycjA2TTcyWHV2dy82NDA_d3hfZm10PWpwZWc?x-oss-process=image/format,png"></p><p><strong>睡眠排序</strong></p><p><strong>猴子排序</strong></p><p><strong>珠排序</strong></p><p><a href="https://blog.csdn.net/bjweimengshu/article/details/103360199">漫画：三种 “奇葩” 的排序算法</a></p><p>这三种排序算法体现出了发明者天马行空的想象力，大家可以拿来娱乐一下，但是在现实工作中如有排序需求，可千万不要调用它们啊！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRrY3NtSWdpYlRQdEZLVnV4d0JuQ2htMlVCcGNIaWFUNG1vTmdycGxGNERYdHlXdlRxUUlGN3RpYURBLzY0MD93eF9mbXQ9anBlZw?x-oss-process=image/format,png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRrMjM5WXpIaWFGU0RRaWM3RUZNVmg4V1RPTlpvSk1UVXhHUU01NllkQmFPQzR5R0YwRkVFQkNib2cvNjQwP3d4X2ZtdD1qcGVn?x-oss-process=image/format,png"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRrNkZrNDU5ZEZUR3lpYThQYjFPTWliODZ0eXJTZUp3cFNXcUxUVnRoa3Q3ODBQdko5UVVwd0FIdHcvNjQwP3d4X2ZtdD1wbmc?x-oss-process=image/format,png"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRrd0hlbE5UVUdpYmowYTQybGdsU1lQMlVjenFqSTBDZHR4OXJFMjk1aWN0YnBZa25VOFhFWmY2b2cvNjQwP3d4X2ZtdD1qcGVn?x-oss-process=image/format,png"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9OdE81c2lhbEpaR29wcTRsSEtHcnpwU3JncklnWFdpYWRrNmN6bjlkMkx5V2pBOWpQbzM5WG5WbWljTEc5c2s2aWFzaWFndFVHNzNmV1VJRzYycU55NHZUaWJBdy82NDA_d3hfZm10PWpwZWc?x-oss-process=image/format,png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习导引</title>
      <link href="/2020/10/30/git%E5%AD%A6%E4%B9%A0%E5%AF%BC%E5%BC%95/"/>
      <url>/2020/10/30/git%E5%AD%A6%E4%B9%A0%E5%AF%BC%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>对于刚接触github的朋友，git是一个容易让人犯迷糊的事物。本文首先将对git作简要介绍，然后向大家推荐相应的学习内容，希望能帮助到你（*＾-＾*）</p><h4 id="git简介"><a href="#git简介" class="headerlink" title="git简介"></a>git简介</h4><h5 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h5><p>当下最先进的开源<strong>分布式版本控制系统</strong>，可以高效便捷地管理大大小小的项目版本。</p><h5 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h5><p>分布式结构就是将一个完整的系统，按照业务功能，拆分成一个个独立的子系统，在分布式结构中，每个子系统就被称为“服务”。这些子系统能够独立运行在web容器中，它们之间通过RPC方式通信。</p><p>举个例子，假设需要开发一个在线商城。按照微服务的思想，我们需要按照功能模块拆分成多个独立的服务，如：用户服务、产品服务、订单服务、后台管理服务、数据分析服务等等。这一个个服务都是一个个独立的项目，可以独立运行。如果服务之间有依赖关系，那么通过RPC方式调用。</p><p>这样的好处有很多：</p><ol><li>系统之间的耦合度大大降低，可以独立开发、独立部署、独立测试，系统与系统之间的边界非常明确，排错也变得相当容易，开发效率大大提升。</li><li>系统之间的耦合度降低，从而系统更易于扩展。我们可以针对性地扩展某些服务。假设这个商城要搞一次大促，下单量可能会大大提升，因此我们可以针对性地提升订单系统、产品系统的节点数量，而对于后台管理系统、数据分析系统而言，节点数量维持原有水平即可。</li><li>服务的复用性更高。比如，当我们将用户系统作为单独的服务后，该公司所有的产品都可以使用该系统作为用户系统，无需重复开发。</li></ol><h5 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h5><p>版本控制是指对软件开发过程中各种程序代码、<a href="https://baike.baidu.com/item/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/286550">配置文件</a>及说明文档等文件变更的管理。</p><p>通俗地说就是对一个或若干个文件的<strong>内容改动情况按照特定的版本号进行保存</strong>，以便将来浏览者快速清晰了解文件的改动信息（内容变化信息，内容改动时间，作者等）</p><h4 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h4><p><a href="https://www.runoob.com/w3cnote/git-five-minutes-tutorial.html">Git五分钟教程</a></p><p><a href="https://www.runoob.com/manual/git-guide/">git - 简明指南</a></p><p><a href="https://www.runoob.com/w3cnote/git-gui-window.html">Git GUI使用方法</a></p><h4 id="一般使用"><a href="#一般使用" class="headerlink" title="一般使用"></a>一般使用</h4><p>下表中不明白的地方用的时候稍微查下，理解下，平时用多了会熟悉的</p><p><img src="/img/post/git%E5%AD%A6%E4%B9%A0%E5%AF%BC%E5%BC%95/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8.png" alt="Git常用命令速查表" title="Git常用命令速查表"></p><h4 id="系统学习"><a href="#系统学习" class="headerlink" title="系统学习"></a>系统学习</h4><h5 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h5><p>选一个即可</p><p><a href="https://www.runoob.com/git/git-tutorial.html">Git 教程|菜鸟教程</a></p><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的Git教程</a></p><h5 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h5><p><a href="https://git-scm.com/book/zh/v2">git官方中文文档</a></p><h5 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h5><p><a href="https://www.bilibili.com/video/BV1Xt411g7TL?zw">版本控制 Git 视频教程全集（62P）| 6 小时从入门到精通</a></p><iframe src="//player.bilibili.com/player.html?aid=59634634&bvid=BV1Xt411g7TL&cid=103887194&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol><li><p><a href="https://www.zhihu.com/question/20004877/answer/282033178">分布式与集群的区别|知乎</a></p></li><li><p><a href="https://feichen.blog.csdn.net/article/details/81744744?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.pc_relevant_is_cache&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.pc_relevant_is_cache">git常用命令速查表-桌面图</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> 版本控制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拼图游戏</title>
      <link href="/2020/10/25/%E6%8B%BC%E5%9B%BE%E6%B8%B8%E6%88%8F/"/>
      <url>/2020/10/25/%E6%8B%BC%E5%9B%BE%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/sleepyfox-github/Jigsaw-puzzle.git">https://github.com/sleepyfox-github/Jigsaw-puzzle.git</a></p><p>拼图游戏，大一C语言结课作业，依赖于acllib库实现，仅支持Windows环境下运行。</p><h4 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h4><p>滑块拼图是一款策略类游戏，把一幅图案分为相等的若干正方型小方块，取走其中一块留出空位，利用多余的空格滑动其他小方块，打乱图案形成拼图。复位时都不能取下任何小方块，利用缺少的空位滑动图案中的小方块使其复原。</p><p>程序运行后先随机打乱，然后利用鼠标点击将拼图复原。鼠标只能分别控制与空格相邻的上下左右的滑块往空格位移动，判断图片复原则显示拼图完成</p><h4 id="算法分析与概要设计"><a href="#算法分析与概要设计" class="headerlink" title="算法分析与概要设计"></a>算法分析与概要设计</h4><p><img src="/img/post/%E6%8B%BC%E5%9B%BE%E6%B8%B8%E6%88%8F/%E6%B5%81%E7%A8%8B%E5%9B%BE1.png" alt="流程图1" title="流程图1"></p><p><img src="/img/post/%E6%8B%BC%E5%9B%BE%E6%B8%B8%E6%88%8F/%E6%B5%81%E7%A8%8B%E5%9B%BE2.png" alt="流程图2" title="流程图2"></p><h4 id="核心算法的详细设计与实现"><a href="#核心算法的详细设计与实现" class="headerlink" title="核心算法的详细设计与实现"></a>核心算法的详细设计与实现</h4><h5 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h5><p>音效加载与图片加载类似，原图片和拼图完成后播放的音乐均直接加载，而9个拼图块与9个钢琴音效均借助对文件名的修改，从而实现每次循环将不同的jpg或mp3文件加载进ACL_Image或ACL_Sound类型数组的相应空间中。</p><p><img src="/img/post/%E6%8B%BC%E5%9B%BE%E6%B8%B8%E6%88%8F/%E5%8A%A0%E8%BD%BD.png" alt="加载" title="加载"></p><h5 id="初始化map坐标数组"><a href="#初始化map坐标数组" class="headerlink" title="初始化map坐标数组"></a>初始化map坐标数组</h5><p>map数组为二维数组，定义为map[ROW][COL]，用于存储图片编号，行标和列标对应具体位置。初始化过程十分简单，行标和列标二重循环，将行标+列标*总行数（i + j*ROW）的值赋给map[i][j]即可。但对于之后拼图块的交换十分方便。</p><h5 id="随机打乱函数"><a href="#随机打乱函数" class="headerlink" title="随机打乱函数"></a>随机打乱函数</h5><p><img src="/img/post/%E6%8B%BC%E5%9B%BE%E6%B8%B8%E6%88%8F/%E9%9A%8F%E6%9C%BA%E6%89%93%E4%B9%B1%E5%87%BD%E6%95%B01.png" alt="随机打乱函数1" title="随机打乱函数1"></p><p><img src="/img/post/%E6%8B%BC%E5%9B%BE%E6%B8%B8%E6%88%8F/%E9%9A%8F%E6%9C%BA%E6%89%93%E4%B9%B1%E5%87%BD%E6%95%B02.png" alt="随机打乱函数2" title="随机打乱函数2"></p><h5 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h5><p>原图片单独绘制，9个拼图块（含空白块）按i，j的二重循环，由“putImageScale(&amp;img[map[i][j]], i * SIZE, j * SIZE, SIZE, SIZE);”语句绘制，便可呈现打乱后的图片</p><h5 id="鼠标控制移动"><a href="#鼠标控制移动" class="headerlink" title="鼠标控制移动"></a>鼠标控制移动</h5><p>鼠标点击控制与空格相邻的上下左右的滑块往空格位移动</p><p><img src="/img/post/%E6%8B%BC%E5%9B%BE%E6%B8%B8%E6%88%8F/%E9%BC%A0%E6%A0%87%E6%8E%A7%E5%88%B6%E7%A7%BB%E5%8A%A8.png" alt="鼠标控制移动" title="鼠标控制移动"></p><h5 id="判断拼图是否复原"><a href="#判断拼图是否复原" class="headerlink" title="判断拼图是否复原"></a>判断拼图是否复原</h5><p>在i,j二重循环下，判断map[i][j] 是否等于i + j * ROW（即map的初始值）。若二者相等，count(初值为0)做自增操作。循环结束，判断count是否等于9，若等，则判定为复原，显示拼图完成，并播放音乐。</p><h4 id="边界测试Debug"><a href="#边界测试Debug" class="headerlink" title="边界测试Debug"></a>边界测试Debug</h4><h5 id="鼠标点击原图片"><a href="#鼠标点击原图片" class="headerlink" title="鼠标点击原图片"></a>鼠标点击原图片</h5><h6 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h6><p>当原图片右侧为空白块时，点击原图片，二者发生奇怪的交换，bug如下图</p><p><img src="/img/post/%E6%8B%BC%E5%9B%BE%E6%B8%B8%E6%88%8F/Bug.png" alt="Bug" title="Bug"></p><h6 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h6><p>对交换图片的条件作进一步限制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*游戏过程*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MouseEvent</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> button, <span class="type">int</span> event)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> r, c;</span><br><span class="line">    <span class="comment">//修改为if (x &lt; (WNDWIDTH - SIZE) &amp;&amp; (button == LEFT_BUTTON &amp;&amp; event == BUTTON_DOWN))</span></span><br><span class="line">    <span class="keyword">if</span> (button == LEFT_BUTTON &amp;&amp; event == BUTTON_DOWN)</span><br><span class="line">    &#123;</span><br><span class="line">        c = y / SIZE;</span><br><span class="line">        r = x / SIZE;</span><br><span class="line">        <span class="keyword">if</span> ((r==r0&amp;&amp;c==c0<span class="number">-1</span>)||(r==r0&amp;&amp;c==c0+<span class="number">1</span>)||   <span class="comment">//通过鼠标点击时的坐标与空白块坐标比对，判断是否可交换</span></span><br></pre></td></tr></table></figure><h5 id="拼图完成后鼠标移动"><a href="#拼图完成后鼠标移动" class="headerlink" title="拼图完成后鼠标移动"></a>拼图完成后鼠标移动</h5><h6 id="Bug-1"><a href="#Bug-1" class="headerlink" title="Bug"></a>Bug</h6><p>拼图完成后将播放音乐，但鼠标移动会再次触发监听，反复重播音乐，影响体验。</p><h6 id="Debug-1"><a href="#Debug-1" class="headerlink" title="Debug"></a>Debug</h6><p>声明一个全局变量boolean suc &#x3D; true;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断拼图是否复原</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ROW; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; COL; j++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == i + j * ROW)<span class="comment">//将map数组中的值与初始值比较，从而判断</span></span><br><span class="line">            count++;</span><br><span class="line"><span class="keyword">if</span> (count == ROW * COL)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (suc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> str[<span class="number">50</span>];</span><br><span class="line">        playSound(winsound, <span class="number">1</span>);</span><br><span class="line">        sprintf_s(str, <span class="number">50</span>, <span class="string">&quot;拼图完成&quot;</span>);</span><br><span class="line">        beginPaint();</span><br><span class="line">        setTextSize(<span class="number">40</span>);</span><br><span class="line">        paintText(WNDWIDTH - <span class="number">180</span>, <span class="number">20</span>, str);<span class="comment">//绘制文字</span></span><br><span class="line">        endPaint();</span><br><span class="line">        suc = <span class="literal">false</span>;<span class="comment">//使得成功效果只触发一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h4><p>1.程序成功运行，拼图已打乱，并已加载绘制，原图片绘制在窗口右侧。</p><p><img src="/img/post/%E6%8B%BC%E5%9B%BE%E6%B8%B8%E6%88%8F/beginning.png" alt="beginning" title="beginning"></p><p>2.鼠标左键点击控制与空格相邻的上下左右的滑块往空格位移动，移动时伴有钢琴音效，不同图片音效不同；点击其他区域无响应</p><p><img src="/img/post/%E6%8B%BC%E5%9B%BE%E6%B8%B8%E6%88%8F/play.png" alt="play" title="play"></p><p>3.拼图复原，窗口右上角显示拼图完成，并播放一段音乐</p><p><img src="/img/post/%E6%8B%BC%E5%9B%BE%E6%B8%B8%E6%88%8F/end.png" alt="end" title="end"></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约瑟夫生死游戏</title>
      <link href="/2020/10/22/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%94%9F%E6%AD%BB%E6%B8%B8%E6%88%8F/"/>
      <url>/2020/10/22/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%94%9F%E6%AD%BB%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>用循环链表实现：N个乘客同乘一艘船，因为严重超载，加上风高浪大，危险万分，因此船长告诉乘客，只有将部分乘客投入海中，其余人才能幸免于难。 无奈，大家只得同意这种办法。于是N个人围成一圈(从1，2，3…N分别编号)。由编号为1的人开始，依次报数，数到第M人，便把他投入大海中， 然后再从他的下一个人数起，数到第M人，再将他扔到大海中，如此循环地进行，直到剩下K个乘客为止。按顺序依次输出被扔下大海的乘客的编号。</p><p>提交格式： 实现int * solve(int N,int M,int K)函数。 函数参数为乘客人数N、间隔人数M和剩余乘客人数K，1&lt;&#x3D;N&lt;&#x3D;1000，1&lt;&#x3D;M&lt;&#x3D;500000，0&lt;&#x3D;K&lt;N。 函数返回值为按顺序被扔下大海乘客编号的数组。 请不要printf输出任何内容。</p><h5 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a><strong>核心思路</strong></h5><ol><li><p>创建并初始化循环链表；</p></li><li><p>按照间隔人数M删除节点，同时记录被扔下大海乘客编号；</p></li><li><p>返回按顺序被扔下大海乘客编号的数组地址。</p></li></ol><h5 id="实现要点"><a href="#实现要点" class="headerlink" title="实现要点"></a><strong>实现要点</strong></h5><ol><li><p>头节点不存储编号，循环时注意绕开；</p></li><li><p>动态内存分配后，应立即判断是否分配成功；</p></li><li><p>删除i&#x3D;&#x3D;M处节点时，需从i&#x3D;&#x3D;M-1处节点对下一个节点进行判断，从而绕开头节点。这使得当M&#x3D;&#x3D;1时，需从i&#x3D;&#x3D;0处节点进行判断,不在i的循环范围1~M之中。故M&#x3D;&#x3D;1的情况须单独处理。</p></li></ol><h5 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a><strong>测试样例</strong></h5><p>输入样例1： 9  3  2 输出样例1： 3 6 9 4 8 5 2</p><p>输入样例2： 12 5 6 输出样例2： 5 10 3 9 4 12</p><p>输入样例3：  7  1 3 输出样例3： 5  6  7</p><h5 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a><strong>源代码</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> d;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; node;</span><br><span class="line"><span class="type">int</span>* <span class="title function_">solve</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> M, <span class="type">int</span> K)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span> n,<span class="type">int</span> k)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n, k, m;</span><br><span class="line"><span class="type">int</span>* data;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入人数n，间隔人数m,剩余人数k:\n&quot;</span>);</span><br><span class="line">scanf_s(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">data = solve(n, m, k);</span><br><span class="line">print(data,n,k);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* <span class="title function_">solve</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> M, <span class="type">int</span> K)</span></span><br><span class="line">&#123;</span><br><span class="line">node* Header = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">    <span class="keyword">if</span> (!Header)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">node* p, *q;</span><br><span class="line">Header-&gt;next = Header;</span><br><span class="line">p = Header;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">q = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line"><span class="keyword">if</span> (!q)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">q-&gt;d = i;</span><br><span class="line">q-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = q;</span><br><span class="line">p = q;</span><br><span class="line">&#125;</span><br><span class="line">p = Header-&gt;next;</span><br><span class="line"><span class="type">int</span> z = N - K;</span><br><span class="line"><span class="type">int</span>* a = (<span class="type">int</span>*)<span class="built_in">malloc</span>(z*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (!a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>, j = N,s=<span class="number">0</span>;<span class="comment">//i控制每M个人删除;j存储剩余人数 </span></span><br><span class="line"><span class="keyword">if</span> (M == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; z; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[s++] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (j &gt; K)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == M - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next != Header)<span class="comment">//不是删除第一个结点 </span></span><br><span class="line">&#123;</span><br><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">a[s++] = q-&gt;d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//删除第一个结点 </span></span><br><span class="line">&#123;</span><br><span class="line">q = Header-&gt;next;</span><br><span class="line">Header-&gt;next = q-&gt;next;</span><br><span class="line">a[s++] = q-&gt;d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next != Header)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">p = Header-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">--j;</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next == Header)</span><br><span class="line">&#123;</span><br><span class="line">p = Header-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>* a,<span class="type">int</span> n,<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (n-k); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Graph Theory</title>
      <link href="/2020/10/12/Graph_Theory/"/>
      <url>/2020/10/12/Graph_Theory/</url>
      
        <content type="html"><![CDATA[<p>DM_lecture 第六部分 Graph Theory</p><p><img src="/img/post/Graph_Theory/Graph_Theory.png" alt="Graph Theory" title="Graph Theory"></p>]]></content>
      
      
      <categories>
          
          <category> 离散数学 </category>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维导图 </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Relations</title>
      <link href="/2020/10/12/Relations/"/>
      <url>/2020/10/12/Relations/</url>
      
        <content type="html"><![CDATA[<p>DM_lecture 第五部分 Relations</p><p><img src="/img/post/Relations/Relations.png" alt="Relations" title="Relations"></p>]]></content>
      
      
      <categories>
          
          <category> 离散数学 </category>
          
          <category> 关系 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维导图 </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithms</title>
      <link href="/2020/10/12/Algorithms/"/>
      <url>/2020/10/12/Algorithms/</url>
      
        <content type="html"><![CDATA[<p>DM_lecture 第四部分 Algorithms</p><p><img src="/img/post/Algorithms/Algorithms.png" alt="Algorithms" title="Algorithms"></p>]]></content>
      
      
      <categories>
          
          <category> 离散数学 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维导图 </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Induction and Recursion</title>
      <link href="/2020/10/12/Induction_and_Recursion/"/>
      <url>/2020/10/12/Induction_and_Recursion/</url>
      
        <content type="html"><![CDATA[<p>DM_lecture 第三部分 Induction and Recursion</p><p><img src="/img/post/Induction_and_Recursion/Induction_and_Recursion.png" alt="Induction and Recursion" title="Induction and Recursion"></p>]]></content>
      
      
      <categories>
          
          <category> 离散数学 </category>
          
          <category> 推导与递归 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维导图 </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Set Theory</title>
      <link href="/2020/10/12/Set_Theory/"/>
      <url>/2020/10/12/Set_Theory/</url>
      
        <content type="html"><![CDATA[<p>DM_lecture 第二部分 Set Theory</p><p><img src="/img/post/Set_Theory/Set_Theory.png" alt="Set Theory" title="Set Theory"></p>]]></content>
      
      
      <categories>
          
          <category> 离散数学 </category>
          
          <category> 集合论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维导图 </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Foundations of Logic</title>
      <link href="/2020/10/12/Foundations_of_Logic/"/>
      <url>/2020/10/12/Foundations_of_Logic/</url>
      
        <content type="html"><![CDATA[<p>DM_lecture 第一部分 Foundations of Logic</p><p><img src="/img/post/Foundations_of_Logic/Foundations_of_Logic.png" alt="Foundations of Logic" title="Foundations of Logic"></p>]]></content>
      
      
      <categories>
          
          <category> 离散数学 </category>
          
          <category> 逻辑基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思维导图 </tag>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/10/06/Hello_World/"/>
      <url>/2020/10/06/Hello_World/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://sleepyfox-github.github.io/">sleepyfox’s blog</a>! This is my very first post. Click <a href="https://sleepyfox-github.github.io/about/">about</a> for more info. If you get any problems when visiting my blog, you can contact me through <a href="mailto:wanli.0ziyuan@gmail.com">my email</a>. I’d be delighted if you star me on <a href="https://github.com/sleepyfox-github?tab=repositories">GitHub</a>.😄</p><h3 id="Why-I-build-this-blog-site"><a href="#Why-I-build-this-blog-site" class="headerlink" title="Why I build this blog site"></a>Why I build this blog site</h3><ol><li>记录学习；</li><li>分享交流；</li><li>Just for fun..😂</li></ol><h3 id="How-I-build-this-blog-site"><a href="#How-I-build-this-blog-site" class="headerlink" title="How I build this blog site"></a>How I build this blog site</h3><p>Hexo生成静态页面，然后将代码托管到GitHub Pages。</p><p>文章编辑工具用的是Typora。</p><p>Valine评论系统借助LeanCloud作为数据库搭建。</p><p>Waline评论系统除了LeanCloud云数据库，还使用了Vercel部署服务端。</p><p>博客原本使用的主题为 Next下的Muse，大致效果如下图：</p><p><img src="/img/post/Hello_World/previous_blog_page.png" alt="previous blog page" title="previous blog page"></p><p><img src="/img/post/Hello_World/previous_blog_post.png" alt="previous blog post" title="previous blog post"></p><p>主要参照教程如下：</p><ul><li><p><a href="https://zhuanlan.zhihu.com/p/102592286?utm_source=qq&utm_medium=social&utm_oi=1124773277125697536">从零开始搭建个人博客（超详细）</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/69217131">网站ICP备案和公安备案流程</a></p></li><li><p><a href="https://www.jianshu.com/p/695283187b62">【官方支持】让个人域名下Github Pages完美支持https</a></p></li></ul><p>现在博客使用的主题为 butterfly，主要参照教程如下：</p><ul><li><p><a href="https://blog.csdn.net/mjh1667002013/article/details/129290903">【Hexo】Hexo搭建Butterfly主题并快速美化</a></p></li><li><p><a href="https://wei-ll.github.io/2023/06/23/Butterfly%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/index.html">Hexo + Butterfly主题美化</a></p></li><li><p><a href="https://butterfly.js.org/posts/4aa8abbe/#%E5%8F%83%E6%95%B8%E8%A8%AD%E7%BD%AE">Butterfly 安裝文檔(三) 主題配置-1</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/578681041">Hexo中Buttefly最新教程总览</a></p></li></ul><h3 id="In-the-end"><a href="#In-the-end" class="headerlink" title="In the end"></a>In the end</h3><p><em>Don’t try to understand it, feel it.</em></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
